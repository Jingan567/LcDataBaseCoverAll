<!DOCTYPE html>
<!-- saved from url=(0109)file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="./pragma_files/sqlite.css" rel="stylesheet">
<title _msttexthash="31795439" _msthash="0">SQLite 支持的 pragma 语句</title>
<!-- path= -->
</head>
<body>
<div class="nosearch">
<a href="https://www.sqlite.org/index.html">
<img class="logo" src="./pragma_files/sqlite370_banner.gif" alt="SQLite" border="0" _mstalt="70863" _msthash="1">
</a>
<div><!-- IE hack to prevent disappearing logo --></div>
<div class="tagline desktoponly" _msttexthash="53246063" _msthash="2">小。快。可靠。<br _istranslated="1">选择任意三个。</div>
<div class="menu mainmenu">
<ul>
<li><a href="https://www.sqlite.org/index.html" _msttexthash="2136498" _msthash="3">家</a>
</li><li class="mobileonly" _msthidden="1"><a href="https://www.sqlite.org/javascript:void(0)" onclick="toggle_div(&quot;submenu&quot;)" _msttexthash="45591" _msthidden="1" _msthash="4">Menu</a>
</li><li class="wideonly"><a href="https://www.sqlite.org/about.html" _msttexthash="5448781" _msthash="5">大约</a>
</li><li class="desktoponly"><a href="https://www.sqlite.org/docs.html" _msttexthash="5144373" _msthash="6">文档</a>
</li><li class="desktoponly"><a href="https://www.sqlite.org/download.html" _msttexthash="5638321" _msthash="7">下载</a>
</li><li class="wideonly"><a href="https://www.sqlite.org/copyright.html" _msttexthash="9675445" _msthash="8">许可证</a>
</li><li class="desktoponly"><a href="https://www.sqlite.org/support.html" _msttexthash="4993053" _msthash="9">支持</a>
</li><li class="desktoponly"><a href="https://www.sqlite.org/prosupport.html" _msttexthash="5377151" _msthash="10">购买</a>
</li><li class="search" id="search_menubutton" _msthidden="1" style="display: none;">
<a href="https://www.sqlite.org/javascript:void(0)" onclick="toggle_search()" _msttexthash="74607" _msthidden="1" _msthash="11">Search</a>
</li></ul>
</div>
<div class="menu submenu" id="submenu" _msthidden="5">
<ul _msthidden="5">
<li _msthidden="1"><a href="https://www.sqlite.org/about.html" _msttexthash="60892" _msthidden="1" _msthash="12">About</a>
</li><li _msthidden="1"><a href="https://www.sqlite.org/docs.html" _msttexthash="234962" _msthidden="1" _msthash="13">Documentation</a>
</li><li _msthidden="1"><a href="https://www.sqlite.org/download.html" _msttexthash="113308" _msthidden="1" _msthash="14">Download</a>
</li><li _msthidden="1"><a href="https://www.sqlite.org/support.html" _msttexthash="100646" _msthidden="1" _msthash="15">Support</a>
</li><li _msthidden="1"><a href="https://www.sqlite.org/prosupport.html" _msttexthash="113477" _msthidden="1" _msthash="16">Purchase</a>
</li></ul>
</div>
<div class="searchmenu" id="searchmenu" _msthidden="3">
<form method="GET" action="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/search" _msthidden="3">
<select name="s" id="searchtype" _msthidden="2">
<option value="d" _msttexthash="416429" _msthidden="1" _msthash="17">Search Documentation</option>
<option value="c" _msttexthash="276705" _msthidden="1" _msthash="18">Search Changelog</option>
</select>
<input type="text" name="q" id="searchbox" value="">
<input type="submit" value="Go" _msthidden="A" _mstvalue="18005" _msthash="19">
</form>
</div>
</div>
<script>
function toggle_div(nm) {
var w = document.getElementById(nm);
if( w.style.display=="block" ){
w.style.display = "none";
}else{
w.style.display = "block";
}
}
function toggle_search() {
var w = document.getElementById("searchmenu");
if( w.style.display=="block" ){
w.style.display = "none";
} else {
w.style.display = "block";
setTimeout(function(){
document.getElementById("searchbox").focus()
}, 30);
}
}
function div_off(nm){document.getElementById(nm).style.display="none";}
window.onbeforeunload = function(e){div_off("submenu");}
/* Disable the Search feature if we are not operating from CGI, since */
/* Search is accomplished using CGI and will not work without it. */
if( !location.origin || 1 ){
document.getElementById("search_menubutton").style.display = "none";
}
/* Used by the Hide/Show button beside syntax diagrams, to toggle the */
function hideorshow(btn,obj){
var x = document.getElementById(obj);
var b = document.getElementById(btn);
if( x.style.display!='none' ){
x.style.display = 'none';
b.innerHTML='show';
}else{
x.style.display = '';
b.innerHTML='hide';
}
return false;
}

</script>

<h1 align="center" _msttexthash="10016357" _msthash="20">PRAGMA 语句</h1>



<p _msttexthash="1914075748" _msthash="21">PRAGMA 语句是特定于 SQLite 的 SQL 扩展，用于
修改 SQLite 库的作或查询 SQLite 库
内部（非表）数据。PRAGMA 语句是使用相同的
接口与其他 SQLite 命令（例如 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_select.html" _istranslated="1">SELECT、</a><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_insert.html" _istranslated="1">INSERT</a>）一样，但它是
在以下重要方面有所不同：</p>
<ul>
<li _msttexthash="210798315" _msthash="22">pragma 命令特定于 SQLite，并且是
 与任何其他 SQL 数据库引擎不兼容。</li><li _msttexthash="295129107" _msthash="23">将来可能会删除特定的 pragma 语句并添加其他语句
 SQLite 的版本。不能保证向后兼容。</li><li _msttexthash="714319385" _msthash="24">如果发出未知 pragma，则不会生成错误消息。
 未知的 pragma 将被简单地忽略。这意味着如果
 pragma 语句，该库不会将事实告知用户。</li><li _msttexthash="8065169047" _msthash="25">一些 pragma 在 SQL 编译阶段生效，而不是
 执行阶段。这意味着如果使用 C 语言 <a href="https://www.sqlite.org/c3ref/prepare.html" _istranslated="1">sqlite3_prepare（）、</a><a href="https://www.sqlite.org/c3ref/step.html" _istranslated="1">sqlite3_step（）、</a><a href="https://www.sqlite.org/c3ref/finalize.html" _istranslated="1">sqlite3_finalize（）</a> API（或类似的包装器
 接口），编译指示可能会在 <a href="https://www.sqlite.org/c3ref/prepare.html" _istranslated="1">sqlite3_prepare（）</a> 调用期间运行，
 而不是像普通 SQL 语句那样在 <a href="https://www.sqlite.org/c3ref/step.html" _istranslated="1">sqlite3_step（）</a> 调用期间。
 或者 pragma 可能会像往常一样在 sqlite3_step（） 期间运行
 SQL 语句。编译指示是否在 sqlite3_prepare（） 期间运行
 或 sqlite3_step（） 取决于 pragma 和特定的版本
 的 SQLite 中。</li><li _msttexthash="1696683625" _msthash="26">SQL 语句的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_explain.html" _istranslated="1">EXPLAIN</a> 和 <a href="https://www.sqlite.org/eqp.html" _istranslated="1">EXPLAIN QUERY PLAN</a> 前缀
 仅影响 <a href="https://www.sqlite.org/c3ref/step.html" _istranslated="1">sqlite3_step（）</a> 期间语句的行为。
 这意味着在 <a href="https://www.sqlite.org/c3ref/prepare.html" _istranslated="1">sqlite3_prepare（）</a> 期间生效的 PRAGMA 语句将以相同的方式运行，无论
 而不是它们以 “EXPLAIN” 开头。</li></ul>

<p _msttexthash="730519452" _msthash="27">SQLite 的 C 语言 API 提供了 <a href="https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma" _istranslated="1">SQLITE_FCNTL_PRAGMA</a> <a href="https://www.sqlite.org/c3ref/file_control.html" _istranslated="1">文件控件</a>，该控件为 <a href="https://www.sqlite.org/vfs.html" _istranslated="1">VFS</a> 实现提供了
有机会添加新的 PRAGMA 语句或覆盖
内置的 PRAGMA 语句。</p>


<hr><a name="syntax"></a>
<h2 _msttexthash="20164950" _msthash="28">PRAGMA 命令语法</h2>
<p><b><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/syntax/pragma-stmt.html" _msttexthash="20990593" _msthash="29">pragma-stmt 中：</a></b>
<button id="x9d6dfba0" onclick="hideorshow(&quot;x9d6dfba0&quot;,&quot;x5f7c219f&quot;)" _msttexthash="7070024" _msthash="30">隐藏</button></p>
 <div id="x5f7c219f" class="imgcontainer">
 <div style="max-width:824px"><svg xmlns="http://www.w3.org/2000/svg" class="pikchr" viewBox="0 0 824.352 99.576" width="824.352" height="99.576">
<circle cx="5" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="32,17 20,21 20,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17L26,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M47,32L104,32A15 15 0 0 0 119 17A15 15 0 0 0 104 2L47,2A15 15 0 0 0 32 17A15 15 0 0 0 47 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="75" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="13683553" _mstHash="31">编译指示</text>
<polygon points="155,17 143,21 143,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M119,17L149,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M170,32L266,32A15 15 0 0 0 282 17A15 15 0 0 0 266 2L170,2A15 15 0 0 0 155 17A15 15 0 0 0 170 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="218" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="11747619" _mstHash="32">架构名称</text>
<polygon points="305,17 293,21 293,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M282,17L299,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M320,32A15 15 0 0 0 335 17A15 15 0 0 0 320 2A15 15 0 0 0 305 17A15 15 0 0 0 320 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="320" y="17" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="4186" _mstHash="33">.</text>
<polygon points="371,17 359,21 359,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M335,17L365,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M386,32L483,32A15 15 0 0 0 498 17A15 15 0 0 0 483 2L386,2A15 15 0 0 0 371 17A15 15 0 0 0 386 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="435" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="21630180" _mstHash="34">编译指示名称</text>
<polygon points="540,82 528,86 528,77" style="fill:rgb(0,0,0)"></polygon>
<path d="M498,17 L 506,17 Q 513,17 513,32 L 513,67 Q 513,82 524,82 L 534,82" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M555,97A15 15 0 0 0 570 82A15 15 0 0 0 555 67A15 15 0 0 0 540 82A15 15 0 0 0 555 97Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="555" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">(</text>
<polygon points="593,82 582,86 582,77" style="fill:rgb(0,0,0)"></polygon>
<path d="M570,82L587,82" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M593,97L720,97L720,67L593,67Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="656" y="82" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="78710879" _mstHash="35">pragma-value （编译指示值）</text>
<polygon points="743,82 731,86 731,77" style="fill:rgb(0,0,0)"></polygon>
<path d="M720,82L737,82" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M758,97A15 15 0 0 0 773 82A15 15 0 0 0 758 67A15 15 0 0 0 743 82A15 15 0 0 0 758 97Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="758" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">)</text>
<polygon points="814,17 803,21 803,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M773,82 L 780,82 Q 788,82 788,67 L 788,32 Q 788,17 798,17 L 809,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<circle cx="818" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="540,44 528,48 528,40" style="fill:rgb(0,0,0)"></polygon>
<path d="M498,17 L 506,17 Q 513,17 513,30 Q 513,44 524,44 L 534,44" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M555,59A15 15 0 0 0 570 44L570,44A15 15 0 0 0 555 29A15 15 0 0 0 540 44L540,44A15 15 0 0 0 555 59Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="555" y="44" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">=</text>
<polygon points="593,44 582,48 582,40" style="fill:rgb(0,0,0)"></polygon>
<path d="M570,44L587,44" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M593,59L720,59L720,29L593,29Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="656" y="44" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="78710879" _mstHash="36">pragma-value （编译指示值）</text>
<polygon points="773,44 761,48 761,40" style="fill:rgb(0,0,0)"></polygon>
<path d="M720,44L767,44" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M773,44 L 780,44 Q 788,44 788,36 L 788,29" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="656,17 645,21 645,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M498,17L651,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M656,17L803,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="218,44 207,48 207,40" style="fill:rgb(0,0,0)"></polygon>
<path d="M119,17 L 126,17 Q 134,17 134,30 Q 134,44 149,44 L 198,44 L 213,44" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M218,44 L 335,44 Q 350,44 350,30 Q 350,17 357,17 L 365,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
</svg>
</div>
<p><b><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/syntax/pragma-value.html" _msttexthash="30860375" _msthash="37">pragma-value 的值：</a></b>
<button id="x87e7202d" onclick="hideorshow(&quot;x87e7202d&quot;,&quot;xf58fa64f&quot;)" _msttexthash="7070024" _msthash="38">隐藏</button></p>
 <div id="xf58fa64f" class="imgcontainer">
 <div style="max-width:264px"><svg xmlns="http://www.w3.org/2000/svg" class="pikchr" viewBox="0 0 264.499 110.16" width="264.499" height="110.16">
<circle cx="5" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="63,17 51,21 51,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17L57,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M63,32L201,32L201,2L63,2Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="132" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="15497131" _mstHash="39">有符号编号</text>
<polygon points="255,17 243,21 243,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M201,17L249,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<circle cx="258" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<path d="M78,70L105,70A15 15 0 0 0 120 55L120,55A15 15 0 0 0 105 39L78,39A15 15 0 0 0 63 55L63,55A15 15 0 0 0 78 70Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="92" y="55" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="4389879" _mstHash="40">名字</text>
<path d="M78,108L171,108A15 15 0 0 0 186 92A15 15 0 0 0 171 77L78,77A15 15 0 0 0 63 92A15 15 0 0 0 78 108Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="125" y="92" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="82041609" _mstHash="41">signed-literal （有符号文本）</text>
<polygon points="63,92 51,97 51,88" style="fill:rgb(0,0,0)"></polygon>
<path d="M21,17 L 29,17 Q 36,17 36,32 L 36,77 Q 36,92 47,92 L 57,92" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="201,92 189,97 189,88" style="fill:rgb(0,0,0)"></polygon>
<path d="M186,92L195,92" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M201,92 L 208,92 Q 216,92 216,77 L 216,32 Q 216,17 223,17 L 231,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="201,55 189,59 189,50" style="fill:rgb(0,0,0)"></polygon>
<path d="M120,55L195,55" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M201,55 L 208,55 Q 216,55 216,47 L 216,40" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="63,55 51,59 51,50" style="fill:rgb(0,0,0)"></polygon>
<path d="M36,39 L 36,47 Q 36,55 47,55 L 57,55" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
</svg>
</div>
<p><b><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/syntax/signed-number.html" _msttexthash="36550852" _msthash="42">signed-number 的 Signed Number：</a></b>
<button id="x85c3fac1" onclick="hideorshow(&quot;x85c3fac1&quot;,&quot;xa5cbd52d&quot;)" _msttexthash="5609370" _msthash="43">显示</button></p>
 <div id="xa5cbd52d" style="display:none;" class="imgcontainer" _msthidden="1">
 <div style="max-width:292px" _msthidden="1"><svg xmlns="http://www.w3.org/2000/svg" class="pikchr" viewBox="0 0 292.013 99.576" width="292.013" height="99.576" _mstHidden="1">
<circle cx="5" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="50,44 39,48 39,40" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17 L 16,17 Q 24,17 24,30 Q 24,44 34,44 L 45,44" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M66,59A15 15 0 0 0 81 44L81,44A15 15 0 0 0 66 29A15 15 0 0 0 50 44L50,44A15 15 0 0 0 66 59Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="66" y="44" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">+</text>
<polygon points="122,17 111,21 111,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M81,44 L 88,44 Q 96,44 96,30 Q 96,17 106,17 L 116,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M137,32L244,32A15 15 0 0 0 259 17A15 15 0 0 0 244 2L137,2A15 15 0 0 0 122 17A15 15 0 0 0 137 32Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="191" y="17" text-anchor="middle" fill="rgb(0,0,0)" dominant-baseline="central" _mstTextHash="280696" _mstHidden="1" _mstHash="44">numeric-literal</text>
<polygon points="282,17 271,21 271,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M259,17L276,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<circle cx="286" cy="17" r="3.6" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></circle>
<polygon points="50,82 39,86 39,77" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17 L 16,17 Q 24,17 24,32 L 24,67 Q 24,82 34,82 L 45,82" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M66,97A15 15 0 0 0 81 82L81,82A15 15 0 0 0 66 67A15 15 0 0 0 50 82L50,82A15 15 0 0 0 66 97Z" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<text x="66" y="82" text-anchor="middle" font-weight="bold" fill="rgb(0,0,0)" dominant-baseline="central">-</text>
<path d="M81,82 L 88,82 Q 96,82 96,67 L 96,44 L 96,29" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<polygon points="66,17 54,21 54,12" style="fill:rgb(0,0,0)"></polygon>
<path d="M9,17L60,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
<path d="M66,17L111,17" style="fill:none;stroke-width:2.16;stroke:rgb(0,0,0);"></path>
</svg>
</div>
</div>
</div>
</div>


<p _msttexthash="1337747255" _msthash="45">pragma 可以采用零个或一个参数。参数可以是
在括号中，或者它可能用等号与 pragma name 分隔。
这两种语法产生相同的结果。
在许多 pragma 中，参数是布尔值。布尔值可以是以下值之一：</p>

<center>
<b _msttexthash="480766" _msthash="46">1 yes true on<br>0 no false off</b>
</center>

<p _msttexthash="2976353211" _msthash="47">关键字参数可以选择用引号括起来。
（示例：<tt _istranslated="1">'yes' [FALSE]。</tt>一些 pragmas
将 String Literal 作为其参数。当 pragma 采用关键字时
参数，它通常也需要一个等效的数字。
例如，“0” 和 “no” 的含义相同，“1” 和 “yes” 也是如此。
查询设置的值时，许多 pragma 会返回数字
而不是关键字。</p>

<p _msttexthash="3706226771" _msthash="48">pragma 可以在 pragma name 之前有一个可选的 <span class="yyterm" _istranslated="1">schema-name</span>。
<span class="yyterm" _istranslated="1">schema-name</span> 是 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html" _istranslated="1">ATTACH</a> 编辑的数据库的名称
或者 “main” 或 “temp” 表示 main 和 TEMP 数据库。如果可选的
省略 schema name 时，假定为 “main”。在某些 pragma 中，架构
name 没有意义，只需忽略即可。在下面的文档中，
架构名称有意义的 pragma 以
“<i _istranslated="1">架构。”</i>前缀。</p>


<hr><a name="pragfunc"></a>
<h2 _msttexthash="8327111" _msthash="49">PRAGMA 函数</h2>


<p _msttexthash="2264015143" _msthash="50">返回结果且没有副作用的 PRAGMA 可以是
从普通 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_select.html" _istranslated="1">SELECT</a> 语句作为<a href="https://www.sqlite.org/vtab.html#tabfunc2" _istranslated="1">表值函数</a>访问。
对于每个参与的 PRAGMA，相应的表值函数
与 PRAGMA 同名，但前缀为 7 个字符 “pragma_”。
PRAGMA 参数和架构（如果有）作为参数传递给
table-value 函数，并将 schema 作为可选的 last 参数。</p><p _msttexthash="248057732" _msthash="51">例如，有关索引中列的信息可以是
使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_index_info" _istranslated="1">index_info pragma</a> 读取，如下所示：</p><blockquote><pre>PRAGMA index_info('idx52');
</pre></blockquote>

<p _msttexthash="117349544" _msthash="52">或者，可以使用以下方法读取相同的内容：</p><blockquote><pre>SELECT * FROM pragma_index_info('idx52');
</pre></blockquote>

<p _msttexthash="1786403918" _msthash="53">表值函数格式的优点是查询
可以只返回 PRAGMA 列的子集，可以包含 WHERE 子句，
可以使用聚合函数，而表值函数可以是
联接中的多个数据源之一。
例如，要获取架构中所有索引列的列表，请使用
可以查询：</p><blockquote><pre>SELECT DISTINCT m.name || '.' || ii.name AS 'indexed-columns'
  FROM sqlite_schema AS m,
       pragma_index_list(m.name) AS il,
       pragma_index_info(il.name) AS ii
 WHERE m.type='table'
 ORDER BY 1;
</pre></blockquote>

<p _msttexthash="22268181" _msthash="54">补充说明：</p><ul>
<li><p _msttexthash="212157322" _msthash="55">表值函数仅适用于内置 PRAGMA，而不适用于 PRAGMA
使用 <a href="https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlpragma" _istranslated="1">SQLITE_FCNTL_PRAGMA</a> file 控件定义。</p></li><li><p _msttexthash="98935044" _msthash="56">表值函数仅适用于返回结果和
没有副作用。</p></li><li><p _msttexthash="95777669" _msthash="57">此功能可用于实现<a href="https://en.wikipedia.org/wiki/Information_schema" _istranslated="1">信息模式</a>，首先使用</p><blockquote><pre><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html">ATTACH</a> ':memory:' AS 'information_schema';
</pre></blockquote><font _mstmutation="1" _msttexthash="200952726" _msthash="58">然后在该架构中创建实现官方信息架构的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createview.html" _mstmutation="1" _istranslated="1">VIEW</a>
使用表值 PRAGMA 函数的表。</font></li><li><p _msttexthash="444425709" _msthash="59">新增 PRAGMA 的表值函数功能
在 SQLite 版本 3.16.0 （2017-01-02） 中。SQLite 的早期版本
无法使用此功能。</p></li></ul>

<hr><a name="toc"></a>
<h2 _msttexthash="9960769" _msthash="60">PRAGMA 列表</h2>
<div class="columns" style="columns: 12em auto;">
<ul style="padding-top:0;">
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_analysis_limit" _msttexthash="265369" _msthash="61">analysis_limit</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_application_id" _msttexthash="257621" _msthash="62">application_id</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_auto_vacuum" _msttexthash="186641" _msthash="63">auto_vacuum</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_automatic_index" _msttexthash="290160" _msthash="64">automatic_index</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_busy_timeout" _msttexthash="215319" _msthash="65">busy_timeout</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_cache_size" _msttexthash="156806" _msthash="66">cache_size</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_cache_spill" _msttexthash="180089" _msthash="67">cache_spill</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_case_sensitive_like"><s _msttexthash="481130" _msthash="68">case_sensitive_like¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_cell_size_check" _msttexthash="283231" _msthash="69">cell_size_check</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_checkpoint_fullfsync" _msttexthash="462579" _msthash="70">checkpoint_fullfsync</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_collation_list" _msttexthash="265356" _msthash="71">collation_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_compile_options" _msttexthash="296647" _msthash="72">compile_options</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_count_changes"><s _msttexthash="280306" _msthash="73">count_changes¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_data_store_directory"><s _msttexthash="527995" _msthash="74">data_store_directory¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_data_version" _msttexthash="209716" _msthash="75">data_version</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_database_list" _msttexthash="232089" _msthash="76">database_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_default_cache_size"><s _msttexthash="439504" _msthash="77">default_cache_size¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_defer_foreign_keys" _msttexthash="385801" _msthash="78">defer_foreign_keys</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_empty_result_callbacks"><s _msttexthash="599846" _msthash="79">empty_result_callbacks¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_encoding" _msttexthash="6155578" _msthash="80">编码</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_foreign_key_check" _msttexthash="344474" _msthash="81">foreign_key_check</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_foreign_key_list" _msttexthash="323648" _msthash="82">foreign_key_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_foreign_keys" _msttexthash="209781" _msthash="83">foreign_keys</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_freelist_count" _msttexthash="266812" _msthash="84">freelist_count</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_full_column_names"><s _msttexthash="410735" _msthash="85">full_column_names¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_fullfsync" _msttexthash="140426" _msthash="86">fullfsync</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_function_list" _msttexthash="238693" _msthash="87">function_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_hard_heap_limit" _msttexthash="286351" _msthash="88">hard_heap_limit</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_ignore_check_constraints" _msttexthash="618761" _msthash="89">ignore_check_constraints</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_incremental_vacuum" _msttexthash="388674" _msthash="90">incremental_vacuum</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_index_info" _msttexthash="158548" _msthash="91">index_info</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_index_list" _msttexthash="161720" _msthash="92">index_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_index_xinfo" _msttexthash="184392" _msthash="93">index_xinfo</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_integrity_check" _msttexthash="288535" _msthash="94">integrity_check</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_mode" _msttexthash="206180" _msthash="95">journal_mode</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_size_limit" _msttexthash="389935" _msthash="96">journal_size_limit</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_legacy_alter_table" _msttexthash="377858" _msthash="97">legacy_alter_table</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_legacy_file_format" _msttexthash="381680" _msthash="98">legacy_file_format</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_locking_mode" _msttexthash="203814" _msthash="99">locking_mode</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_max_page_count" _msttexthash="261690" _msthash="100">max_page_count</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_mmap_size" _msttexthash="138333" _msthash="101">mmap_size</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_module_list" _msttexthash="185315" _msthash="102">module_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_optimize" _msttexthash="4054648" _msthash="103">优化</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_page_count" _msttexthash="160121" _msthash="104">page_count</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_page_size" _msttexthash="136630" _msthash="105">page_size</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_parser_trace" _msttexthash="249847" _msthash="106">parser_trace²</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_pragma_list" _msttexthash="183248" _msthash="107">pragma_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_query_only" _msttexthash="166218" _msthash="108">query_only</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_quick_check" _msttexthash="177320" _msthash="109">quick_check</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_read_uncommitted" _msttexthash="321633" _msthash="110">read_uncommitted</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_recursive_triggers" _msttexthash="392587" _msthash="111">recursive_triggers</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_reverse_unordered_selects" _msttexthash="658918" _msthash="112">reverse_unordered_selects</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_schema_version" _msttexthash="312585" _msthash="113">schema_version³</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_secure_delete" _msttexthash="230646" _msthash="114">secure_delete</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_short_column_names"><s _msttexthash="448578" _msthash="115">short_column_names¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_shrink_memory" _msttexthash="240045" _msthash="116">shrink_memory</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_soft_heap_limit" _msttexthash="289484" _msthash="117">soft_heap_limit</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_stats" _msttexthash="5031247" _msthash="118">数据³</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_synchronous" _msttexthash="4817228" _msthash="119">同步</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_table_info" _msttexthash="156156" _msthash="120">table_info</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_table_list" _msttexthash="159328" _msthash="121">table_list</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_table_xinfo" _msttexthash="182000" _msthash="122">table_xinfo</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_temp_store" _msttexthash="162942" _msthash="123">temp_store</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_temp_store_directory"><s _msttexthash="530998" _msthash="124">temp_store_directory¹</s></a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_threads" _msttexthash="6201949" _msthash="125">线程</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_trusted_schema" _msttexthash="259363" _msthash="126">trusted_schema</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_user_version" _msttexthash="213590" _msthash="127">user_version</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_vdbe_addoptrace" _msttexthash="334984" _msthash="128">vdbe_addoptrace²</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_vdbe_debug" _msttexthash="193401" _msthash="129">vdbe_debug²</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_vdbe_listing" _msttexthash="251680" _msthash="130">vdbe_listing²</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_vdbe_trace" _msttexthash="193986" _msthash="131">vdbe_trace²</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_wal_autocheckpoint" _msttexthash="389220" _msthash="132">wal_autocheckpoint</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_wal_checkpoint" _msttexthash="261963" _msthash="133">wal_checkpoint</a></li>
<li><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_writable_schema" _msttexthash="335465" _msthash="134">writable_schema³</a></li>
</ul>
</div>

<p _msttexthash="14227070" _msthash="135">笔记：</p><ol>
<li _msttexthash="248196026" _msthash="136">名称被<s _istranslated="1">删除的</s> pragma 将被弃用。不要使用它们。他们存在
以实现历史兼容性。</li><li _msttexthash="97931509" _msthash="137">这些编译指示仅在使用非标准
compile-time 选项。</li><li _msttexthash="178693164" _msthash="138">这些编译指示用于测试 SQLite，不推荐使用
用于应用程序。</li></ol><p></p>
<a name="pragma_analysis_limit"></a>
<h _id="pragma_analysis_limit" style="display:none" _msttexthash="436631" _msthidden="1" _msthash="139"> PRAGMA analysis_limit</h><hr>
   <p><font _mstmutation="1" _msttexthash="1512979" _msthash="140"><b _mstmutation="1" _istranslated="1">PRAGMA analysis_limit;<br _istranslated="1">PRAGMA analysis_limit = </b><i _mstmutation="1" _istranslated="1">N</i></font><b>;</b></p>
   <p _msttexthash="6960617326" _msthash="141">查询或更改<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_analyze.html#approx" _istranslated="1">近似 ANALYZE</a> 设置的限制。
 这是
 由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_analyze.html" _istranslated="1">ANALYZE</a> 命令检查每个索引中的行。
 如果省略参数 <i _istranslated="1">N</i>，则分析限
 保持不变。
 如果限值为零，则分析限值被禁用，并且
 ANALYZE 命令将检查每个索引的所有行。
 如果 N 大于零，则分析限设置为 N
 ，后续的 ANALYZE 命令将停止分析
 之后的每个索引都检查了大约 N 行。
 如果 N 是负数或整数以外的值，则
 则 pragma 的行为就像省略了 N 参数一样。
 在所有情况下，返回的值都是使用的新分析限
 用于后续 ANALYZE 命令。</p><p _msttexthash="1855669595" _msthash="142">此 pragma 可用于帮助 ANALYZE 命令更快地运行
 在大型数据库上。分析结果没有那么好
 当仅检查每个索引的一部分，但结果是
 通常已经足够好了。将 N 设置为 100 或 1000 将允许
 ANALYZE 命令快速运行，即使在巨大的
 数据库文件。</p><p _msttexthash="969202195" _msthash="143">此编译指示是在 SQLite 版本 3.32.0 （2020-05-22） 中添加的。
 当前实现仅使用
 N 值 - 高阶位被静默忽略。未来版本
 的 SQLite 可能会开始使用更高阶的位。</p><p><font _mstmutation="1" _msttexthash="2563673203" _msthash="144">从 SQLite 版本 3.46.0 （2024-05-23） 开始，
 运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_analyze.html" _mstmutation="1" _istranslated="1">ANALYZE</a> 的推荐方法是使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_optimize" _mstmutation="1" _istranslated="1">PRAGMA optimize</a> 命令。<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_optimize" _mstmutation="1" _istranslated="1">PRAGMA optimize</a> 将自动
 设置一个合理的临时分析限制，以确保 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_optimize" _mstmutation="1" _istranslated="1">PRAGMA optimize</a> 命令即使在巨大的
 数据库。使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_optimize" _mstmutation="1" _istranslated="1">PRAGMA optimize</a> 而不是
 直接运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_analyze.html" _mstmutation="1" _istranslated="1">ANALYZE</a> 不需要设置分析限制。</font><a name="pragma_application_id"></a>
<h _id="pragma_application_id" style="display:none" _msttexthash="426231" _msthidden="1" _msthash="145"> PRAGMA application_id</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="82903418" _msthash="146"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">application_id;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">application_id = </b><i _mstmutation="1" _istranslated="1">整数 </i></font><b>;</b>
  
    </p><p _msttexthash="5537023141" _msthash="147">application_id PRAGMA 用于查询或设置 32 位
 位于 offset 处的有符号 big-endian “Application ID” 整数
 68 放入<a href="https://www.sqlite.org/fileformat2.html#database_header" _istranslated="1">数据库头</a>中。使用 SQLite 作为其<a href="https://www.sqlite.org/appfileformat.html" _istranslated="1">应用程序文件格式</a>的应用程序应将应用程序 ID 整数设置为
 一个唯一的整数，以便 <a href="http://www.darwinsys.com/file/" _istranslated="1">file（1）</a> 等实用程序可以确定特定的
 文件类型，而不仅仅是报告 “SQLite3 Database”。一个
 通过查阅 SQLite 源存储库中的 <a href="https://www.sqlite.org/src/artifact?ci=trunk&amp;filename=magic.txt" _istranslated="1">magic.txt</a> 文件，可以看到分配的应用程序 ID。</p><p><font _mstmutation="1" _msttexthash="18306600" _msthash="148">另请参阅 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_user_version" _mstmutation="1" _istranslated="1">user_version pragma</a>。</font><a name="pragma_auto_vacuum"></a>
<h _id="pragma_auto_vacuum" style="display:none" _msttexthash="333489" _msthidden="1" _msthash="149"> PRAGMA auto_vacuum</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="165769461" _msthash="150"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">auto_vacuum;<br _istranslated="1"> PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">auto_vacuum = </b> <i _mstmutation="1" _istranslated="1">0 |无 |1 |完整版 |2 |增量</i></font><b>;</b></p>

    <p _msttexthash="67326753" _msthash="151">在数据库中查询或设置 auto-vacuum 状态。</p>

    <p _msttexthash="7901310885" _msthash="152">auto-vacuum 的默认设置为 0 或 “none”，
 除非使用 <a href="https://www.sqlite.org/compile.html#default_autovacuum" _istranslated="1">SQLITE_DEFAULT_AUTOVACUUM</a> compile-time 选项。
 “none” 设置表示禁用 auto-vacuum。
 当禁用自动 vacuum 并从数据库中删除数据时，
 数据库文件的大小保持不变。未使用的数据库文件
 页面被添加到 “<a href="https://www.sqlite.org/fileformat2.html#freelist" _istranslated="1">freelist</a>” 中，并重新用于后续插入。所以
 不会丢失任何数据库文件空间。但是，数据库文件不会
 收缩。在此模式下，<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 命令可用于重建整个数据库文件，并且
 从而回收未使用的磁盘空间。</p>

    <p _msttexthash="5839376192" _msthash="153">当 auto-vacuum 模式为 1 或 “full” 时，空闲列表页面为
 移动到数据库文件的末尾，数据库文件被截断
 在每次事务提交时删除 Freelist 页面。
 但请注意，auto-vacuum 只会截断空闲列表页面
 从文件中。自动 vacuum 不会对数据库进行碎片整理，也不会对数据库进行碎片整理
 以 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 命令的方式重新打包各个数据库页面。事实上，因为
 它在文件中移动页面，auto-vacuum 实际上可以
 使碎片化变得更糟。</p>

    <p _msttexthash="902381883" _msthash="154">仅当数据库存储了一些
 允许每个数据库页面
 向后追溯到其 referrer。因此，自动吸尘必须
 在创建任何表之前打开。这是不可能的
 在创建表后启用或禁用 auto-vacuum。</p>

    <p _msttexthash="2347223970" _msthash="155">当 auto-vacuum 的值为 2 或 “incremental” 时，附加的
 执行自动 vacuum 所需的信息存储在数据库文件中
 但是 auto-vacuuming 不会在每次提交时自动发生，因为它
 与 auto_vacuum=full 一起。在增量模式下，单独的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_incremental_vacuum" _istranslated="1">incremental_vacuum</a> pragma 必须
 被调用以导致发生自动 vacuum。</p>

    <p _msttexthash="4673177782" _msthash="156">数据库连接可以在完全和增量之间更改
 autovacuum 模式。但是，将
 “none” 到 “full” 或 “incremental” 只能在数据库
 是 new （无表
 ）或通过运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 命令。自
 更改 auto-vacuum 模式，首先使用 auto_vacuum 编译指示设置
 新的所需模式，然后调用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 命令
 重新组织整个数据库文件。要从 “full” 或
 “incremental” 返回 “none” 总是需要运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a>，即使
 在空数据库上。</p>

    <p _msttexthash="285073048" _msthash="157">当 auto_vacuum 编译指示在无参数的情况下调用时，它会
 返回当前 auto_vacuum 模式。</p>
<a name="pragma_automatic_index"></a>
<h _id="pragma_automatic_index" style="display:none" _msttexthash="468598" _msthidden="1" _msthash="158"> PRAGMA automatic_index</h><hr>
    <p><font _mstmutation="1" _msttexthash="47624343" _msthash="159"><b _mstmutation="1" _istranslated="1">PRAGMA automatic_index;<br _istranslated="1">PRAGMA automatic_index = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="73408816" _msthash="160">查询、设置或清除<a href="https://www.sqlite.org/optoverview.html#autoindex" _istranslated="1">自动索引</a>功能。</p><p><font _mstmutation="1" _msttexthash="527313306" _msthash="161">从<a href="https://www.sqlite.org/releaselog/3_7_17.html" _mstmutation="1" _istranslated="1">版本 3.7.17</a> （2013-05-20） 开始，<a href="https://www.sqlite.org/optoverview.html#autoindex" _mstmutation="1" _istranslated="1">自动索引</a>默认启用，
 但是这可能会在SQLite的未来版本中发生变化。</font><a name="pragma_busy_timeout"></a>
<h _id="pragma_busy_timeout" style="display:none" _msttexthash="372151" _msthidden="1" _msthash="162"> PRAGMA busy_timeout</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="36044359" _msthash="163"><b _mstmutation="1" _istranslated="1">PRAGMA busy_timeout;<br _istranslated="1">PRAGMA busy_timeout = </b><i _mstmutation="1" _istranslated="1">毫秒</i></font><b>;</b></p>
    <p _msttexthash="1175772897" _msthash="164">查询或更改<a href="https://www.sqlite.org/c3ref/busy_timeout.html" _istranslated="1">繁忙超时</a>的设置。
 此 pragma 是 <a href="https://www.sqlite.org/c3ref/busy_timeout.html" _istranslated="1">sqlite3_busy_timeout（）</a> C 语言的替代
 interface 的 API 作为 pragma 与 language 一起使用
 不提供对 <a href="https://www.sqlite.org/c3ref/busy_timeout.html" _istranslated="1">sqlite3_busy_timeout（）</a> 的直接访问的绑定。</p><p><font _mstmutation="1" _msttexthash="676918944" _msthash="165">每个数据库连接只能有一个<a href="https://www.sqlite.org/c3ref/busy_handler.html" _mstmutation="1" _istranslated="1">繁忙的处理程序</a>。此 PRAGMA 设置 busy 处理程序
 对于该进程，可能会覆盖任何以前设置的 busy 处理程序。</font><a name="pragma_cache_size"></a>
<h _id="pragma_cache_size" style="display:none" _msttexthash="291564" _msthidden="1" _msthash="166"> PRAGMA cache_size</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="114935418" _msthash="167"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">cache_size;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">cache_size = </b><i _mstmutation="1" _istranslated="1">页;</i><b _mstmutation="1" _istranslated="1"><br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">cache_size = -</b><i _mstmutation="1" _istranslated="1">kibibytes</i></font><b>;</b></p>
    <p _msttexthash="8445126950" _msthash="168">查询或更改建议的最大数据库磁盘页数
 该 SQLite 将在每个打开的数据库文件中立即保存在内存中。是否
 是否接受此建议由 <a href="https://www.sqlite.org/c3ref/pcache_methods2.html" _istranslated="1">Application Defined Page Cache</a> 自行决定。
 SQLite 中内置的默认页面缓存会接受请求，
 但是，其他应用程序定义的页面缓存实现
 可以选择以不同的方式解释建议的缓存大小
 或者完全忽略它。
 默认建议的缓存大小为 -2000，即缓存大小
 限制为 2048000 字节的内存。
 可以使用 <a href="https://www.sqlite.org/compile.html#default_cache_size" _istranslated="1">SQLITE_DEFAULT_CACHE_SIZE</a> 编译时选项更改默认建议的缓存大小。
 TEMP 数据库的默认建议缓存大小为 0 页。</p>

    <p _msttexthash="4132839334" _msthash="169">如果参数 N 为正数，则设置建议的缓存大小
 到 N。如果参数 N 为负数，则
 缓存页数调整为页数，该页数将
 根据当前的
 页面大小。SQLite 记住页面缓存中的页数，
 而不是使用的内存量。因此，如果您使用
 一个负数，然后更改页面大小（使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_page_size" _istranslated="1">PRAGMA page_size</a> 命令），然后更改最大缓存量
 内存将根据页面大小的变化成比例地增加或减少。</p><p _msttexthash="929217900" _msthash="170"><i _istranslated="1">向后兼容性说明：</i>cache_size 为负 N 的行为
 在<a href="https://www.sqlite.org/releaselog/3_7_10.html" _istranslated="1">版本 3.7.10</a> （2012-01-16） 之前有所不同。在
 早期版本中，缓存中的页数是设置的
 设置为绝对值 N。</p>

    <p _msttexthash="499904743" _msthash="171">当您使用 cache_size 编译指示更改缓存大小时，
 更改仅适用于当前会话。缓存大小恢复
 设置为默认值。</p>

    <p><font _mstmutation="1" _msttexthash="2879681532" _msthash="172">默认页面高速缓存实现不会分配
 一次全部缓存内存量。缓存内存
 根据需要以较小的块进行分配。page_cache
 设置是
 cache 可以使用，而不是它将一直使用的内存量。
 这是默认页面缓存实现的行为，但<a href="https://www.sqlite.org/c3ref/pcache_methods2.html" _mstmutation="1" _istranslated="1">应用程序定义的页面缓存</a>是免费的
 如果它愿意，可以采取不同的行为。</font><a name="pragma_cache_spill"></a>
<h _id="pragma_cache_spill" style="display:none" _msttexthash="323037" _msthidden="1" _msthash="173"> PRAGMA cache_spill</h></p><hr>
    <p _msttexthash="87105109" _msthash="174"><b _istranslated="1">PRAGMA cache_spill;<br _istranslated="1">PRAGMA cache_spill=</b><i _istranslated="1">布尔</i><b _istranslated="1">值;<br _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">cache_spill=<i _istranslated="1">N</i>;</b></p>

    <p _msttexthash="6019773448" _msthash="175">cache_spill 编译指示启用或禁用寻呼机的功能
 要将脏缓存页溢出到中间的数据库文件中
 交易。默认情况下，Cache_spill 处于启用状态，大多数应用程序
 应该保持这种状态，因为缓存溢出通常是有利的。
 但是，缓存溢出具有获取数据库文件上的 <a href="https://www.sqlite.org/lockingv3.html#excl_lock" _istranslated="1">EXCLUSIVE 锁</a>的副作用。因此，一些应用程序
 具有大型长时间运行的事务可能希望禁用缓存溢出
 为了防止应用程序获取独占锁
 在数据库上，直到事务 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_transaction.html" _istranslated="1">COMMIT</a>s.</p><p _msttexthash="1261089609" _msthash="176">此 pragma 的 “PRAGMA cache_spill=<i _istranslated="1">N</i>” 形式设置最小值
 发生溢出所需的缓存大小阈值。页数
 In Cache 必须超过 cache_spill 阈值和最大缓存
 size 设置的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_cache_size" _istranslated="1">cache_size</a> 语句，以便溢出到
 发生。</p><p><font _mstmutation="1" _msttexthash="1054314261" _msthash="177">此 pragma 的 “PRAGMA cache_spill=<i _mstmutation="1" _istranslated="1">boolean</i>” 形式适用
 跨附加到数据库连接的所有数据库。但是
 此语句的 “PRAGMA cache_spill=<i _mstmutation="1" _istranslated="1">N</i>” 形式仅适用于
 “main” 架构或指定为
 陈述。</font><a name="pragma_case_sensitive_like"></a>
<h _id="pragma_case_sensitive_like" style="display:none" _msttexthash="629096" _msthidden="1" _msthash="178"> PRAGMA case_sensitive_like</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="30743739" _msthash="179"><b _mstmutation="1" _istranslated="1">PRAGMA case_sensitive_like = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="4966446069" _msthash="180"><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_expr.html#like" _istranslated="1">LIKE</a> 运算符的默认行为是忽略大小写
 用于 ASCII 字符。因此，默认情况下<b _istranslated="1">，'a' LIKE 'A'</b> 是
 真。case_sensitive_like pragma 会安装一个新的应用程序定义
 LIKE 函数，该函数区分大小写或不区分大小写，具体取决于
 在 case_sensitive_like pragma 的值上。
 禁用 case_sensitive_like 时，默认的 LIKE 行为为
 表示。启用 case_sensitive_like 后，大小写变为
 重要。因此，例如，<b _istranslated="1">'a' LIKE 'A'</b> 为 false，但 <b _istranslated="1">'a' LIKE 'a'</b> 仍然是 true。</p>

    <p _msttexthash="2254098912" _msthash="181">此编译指示使用 <a href="https://www.sqlite.org/c3ref/create_function.html" _istranslated="1">sqlite3_create_function（）</a> 重载
 LIKE 和 GLOB 函数，它们可能会覆盖以前的实现
 应用程序注册的 LIKE 和 GLOB。此 pragma
 仅更改 SQL <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_expr.html#like" _istranslated="1">LIKE</a> 运算符的行为。它没有
 更改 <a href="https://www.sqlite.org/c3ref/strlike.html" _istranslated="1">sqlite3_strlike（）</a> C 语言接口的行为，
 始终不区分大小写。</p>

    <p _msttexthash="5157405383" _msthash="182"><b _istranslated="1">警告：</b>如果数据库在
 架构，例如在 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#ckconst" _istranslated="1">CHECK 约束</a>、<a href="https://www.sqlite.org/expridx.html" _istranslated="1">表达式索引</a>或<a href="https://www.sqlite.org/partialindex.html" _istranslated="1">部分索引</a>的 WHERE 子句中，则
 使用此 PRAGMA 更改 LIKE 运算符的定义可以
 使数据库看起来已损坏。<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_integrity_check" _istranslated="1">PRAGMA integrity_check</a> 将报告错误。数据库并没有真正损坏
 将 LIKE 的行为改回
 这是定义架构并填充数据库的时候
 将清除问题。如果 LIKE 的使用仅发生在索引中，则
 然后可以通过运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_reindex.html" _istranslated="1">REINDEX</a> 来清除问题。不过
 不建议使用 case_sensitive_like pragma。</p>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="183"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_cell_size_check"></a>
<h _id="pragma_cell_size_check" style="display:none" _msttexthash="458627" _msthidden="1" _msthash="184"> PRAGMA cell_size_check</h><hr>
    <p><font _mstmutation="1" _msttexthash="46658664" _msthash="185"><b _mstmutation="1" _istranslated="1">PRAGMA cell_size_check <br _istranslated="1">PRAGMA cell_size_check = </b><i _mstmutation="1" _istranslated="1">布尔值</i></font><b>;</b></p>
    <p><font _mstmutation="1" _msttexthash="2503784803" _msthash="186">cell_size_check pragma 启用或禁用额外的健全性
 在最初从磁盘读取数据库 B 树页面时检查它们。
 启用像元大小检查后，可更早地检测到数据库损坏
 并且不太可能“传播”。但是，性能很小
 hit 执行额外检查，因此 Cell Size 检查处于关闭状态
 默认情况下。</font><a name="pragma_checkpoint_fullfsync"></a>
<h _id="pragma_checkpoint_fullfsync" style="display:none" _msttexthash="683371" _msthidden="1" _msthash="187"> PRAGMA checkpoint_fullfsync</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="56306003" _msthash="188"><b _mstmutation="1" _istranslated="1">PRAGMA checkpoint_fullfsync <br _istranslated="1">PRAGMA checkpoint_fullfsync = </b><i _mstmutation="1" _istranslated="1">布尔值</i></font><b>;</b></p>
    <p _msttexthash="1258988289" _msthash="189">查询或更改<a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">检查点</a>作的 fullfsync 标志。
 如果设置了此标志，则使用 F_FULLFSYNC 同步方法
 在支持 F_FULLFSYNC 的系统上执行检查点作期间。
 checkpoint_fullfsync 标志的默认值
 已关闭。只有 Mac OS-X 支持 F_FULLFSYNC。</p>

    <p _msttexthash="419120611" _msthash="190">如果设置了 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_fullfsync" _istranslated="1">fullfsync</a> 标志，则F_FULLFSYNC同步
 method 用于所有同步作，checkpoint_fullfsync
 设置无关紧要。</p>
<a name="pragma_collation_list"></a>
<h _id="pragma_collation_list" style="display:none" _msttexthash="436462" _msthidden="1" _msthash="191"> PRAGMA collation_list</h><hr>
    <p><b _msttexthash="457171" _msthash="192">PRAGMA collation_list;</b></p>
    <p _msttexthash="42154619" _msthash="193">返回为当前
 数据库连接。</p>
<a name="pragma_compile_options"></a>
<h _id="pragma_compile_options" style="display:none" _msttexthash="476801" _msthidden="1" _msthash="194"> PRAGMA compile_options</h><hr>
    <p><b _msttexthash="498277" _msthash="195">PRAGMA compile_options;</b></p>
    <p _msttexthash="965503357" _msthash="196">此编译指示返回<a href="https://www.sqlite.org/compile.html" _istranslated="1"></a>
 构建 SQLite，每行一个选项。省略了 “SQLITE_” 前缀
 从返回的选项名称中。另请参见 <a href="https://www.sqlite.org/c3ref/compileoption_get.html" _istranslated="1">sqlite3_compileoption_get（）</a> C/C++ 接口和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_corefunc.html#sqlite_compileoption_get" _istranslated="1">sqlite_compileoption_get（）</a> SQL 函数。</p>
<a name="pragma_count_changes"></a>
<h _id="pragma_count_changes" style="display:none" _msttexthash="393406" _msthidden="1" _msthash="197"> PRAGMA count_changes</h><hr>
    <p><font _mstmutation="1" _msttexthash="43813497" _msthash="198"><b _mstmutation="1" _istranslated="1">PRAGMA count_changes;<br _istranslated="1">PRAGMA count_changes = </b>布尔值</font><b>;</b></p>

    <p _msttexthash="5072503969" _msthash="199">查询或更改 count-changes 标志。通常，当
 count-changes 标志，<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_insert.html" _istranslated="1">则 INSERT、</a><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_update.html" _istranslated="1">UPDATE</a> 和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_delete.html" _istranslated="1">DELETE</a> 语句
 不返回任何数据。设置 count-changes 后，以下每个命令
 返回一行数据，其中包含一个整数值 - 该
 命令插入、修改或删除的行数。这
 返回的更改计数不包括任何插入、修改
 或触发器执行的删除，则自动进行的任何更改
 通过<a href="https://www.sqlite.org/foreignkeys.html#fk_actions" _istranslated="1">外键作</a>，或由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_upsert.html" _istranslated="1">UPSERT</a> 引起的更新。</p>

    <p _msttexthash="2919848438" _msthash="200">获取行更改计数的另一种方法是使用 <a href="https://www.sqlite.org/c3ref/changes.html" _istranslated="1">sqlite3_changes（）</a> 或 <a href="https://www.sqlite.org/c3ref/total_changes.html" _istranslated="1">sqlite3_total_changes（）</a> 接口。
 不过，有一个微妙的不同。当 INSERT、UPDATE 或
 DELETE 使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtrigger.html#instead_of_trigger" _istranslated="1">INSTEAD OF 触发器</a>对视图运行，
 count_changes pragma 报告视图中的行数
 触发触发器，而 <a href="https://www.sqlite.org/c3ref/changes.html" _istranslated="1">sqlite3_changes（）</a> 和 <a href="https://www.sqlite.org/c3ref/total_changes.html" _istranslated="1">sqlite3_total_changes（）</a> 则不会。</p><p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="201"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_data_store_directory"></a>
<h _id="pragma_data_store_directory" style="display:none" _msttexthash="683618" _msthidden="1" _msthash="202"> PRAGMA data_store_directory</h><hr>
    <p><font _mstmutation="1" _msttexthash="91182767" _msthash="203"><b _mstmutation="1" _istranslated="1">PRAGMA data_store_directory;<br _istranslated="1">PRAGMA data_store_directory = '</b><i _mstmutation="1" _istranslated="1">目录名称</i></font><b>';</b></p>
    <p _msttexthash="556224708" _msthash="204">查询或更改 <a href="https://www.sqlite.org/c3ref/data_directory.html" _istranslated="1">sqlite3_data_directory</a> 全局变量的值
 变量，Windows作系统接口后端使用它来
 确定使用相对
 路径。</p>

    <p _msttexthash="2386134387" _msthash="205">更改 data_store_directory 设置<u _istranslated="1">不是</u>线程安全的。
 如果另一个线程，则从不更改 data_store_directory 设置
 同时运行任何 SQLite 接口。
 这样做会导致未定义的行为。更改 data_store_directory
 设置写入 <a href="https://www.sqlite.org/c3ref/data_directory.html" _istranslated="1">sqlite3_data_directory</a> 全局
 变量，并且该全局变量不受互斥锁保护。</p>

    <p _msttexthash="898561417" _msthash="206">此功能是为没有作系统的 WinRT 提供的
 读取或更改当前工作目录的机制。
 不建议在任何其他上下文中使用此 pragma，并且可能会
 在将来的发行版中被禁止。</p>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="207"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_data_version"></a>
<h _id="pragma_data_version" style="display:none" _msttexthash="363272" _msthidden="1" _msthash="208"> PRAGMA data_version</h><hr>
    <p _msttexthash="12141129" _msthash="209"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">data_version;</b></p>
    <p _msttexthash="1722997770" _msthash="210">“PRAGMA data_version” 命令指示
 数据库文件已修改。
 将数据库内容保存在内存中的交互式程序，或者
 显示数据库内容可以使用 PRAGMA data_version
 命令来确定它们是否需要刷新和重新加载其内存
 或更新屏幕显示。</p>

    <p _msttexthash="3997756919" _msthash="211">由 2 返回的整数值
 从同一连接调用 “PRAGMA data_version”
 如果将更改提交到数据库，则可能会有所不同
 在此期间通过任何其他连接。
 对于所进行的提交，“PRAGMA data_version” 值保持不变
 在同一个数据库连接上。
 “PRAGMA data_version” 的行为对于所有数据库都是相同的
 连接，包括单独进程中的数据库连接
 和<a href="https://www.sqlite.org/sharedcache.html" _istranslated="1">共享缓存</a>数据库连接。</p><p><font _mstmutation="1" _msttexthash="1615991403" _msthash="212">“PRAGMA data_version” 值是每个
 数据库连接，以及两个并发调用返回的 so 值
 的 “PRAGMA data_version” 是
 即使底层数据库相同，也经常不同。
 只有比较 “PRAGMA data_version” 值才有意义
 由同一数据库连接在
 时间。</font><a name="pragma_database_list"></a>
<h _id="pragma_database_list" style="display:none" _msttexthash="391963" _msthidden="1" _msthash="213"> PRAGMA database_list</h></p><hr>
    <p><b _msttexthash="411905" _msthash="214">PRAGMA database_list;</b></p>
    <p _msttexthash="3250328536" _msthash="215">此 pragma 的工作方式类似于查询，为每个数据库返回一行
 附加到当前数据库连接。
 第二列是主数据库文件 “temp” 的 “main”
 对于用于存储 TEMP 对象的数据库文件，或者
 ATTACHed 数据库以获取其他数据库文件。
 第三列是数据库文件本身的名称，或者是一个空的
 string（如果数据库未与文件关联）。</p>
<a name="pragma_default_cache_size"></a>
<h _id="pragma_default_cache_size" style="display:none" _msttexthash="579345" _msthidden="1" _msthash="216"> PRAGMA default_cache_size</h><hr>
    <font _mstmutation="1" _msttexthash="102989289" _msthash="217"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">default_cache_size;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">default_cache_size
 = </b><i _mstmutation="1" _istranslated="1">页数</i></font><b>;</b><p></p>

    <p _msttexthash="1762190495" _msthash="218">此 pragma 查询或设置建议的最大页数
 将按打开的数据库文件分配的磁盘缓存。
 此 pragma 与 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_cache_size" _istranslated="1">cache_size</a> 之间的区别在于
 此处设置的值在数据库连接之间保持不变。
 默认缓存大小的值存储在 4 字节中
 big-endian 整数，位于
 database 文件。</p>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="219"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_defer_foreign_keys"></a>
<h _id="pragma_defer_foreign_keys" style="display:none" _msttexthash="587639" _msthidden="1" _msthash="220"> PRAGMA defer_foreign_keys</h><hr>
    <p><font _mstmutation="1" _msttexthash="52423137" _msthash="221"><b _mstmutation="1" _istranslated="1">PRAGMA defer_foreign_keys <br _istranslated="1">PRAGMA defer_foreign_keys = </b><i _mstmutation="1" _istranslated="1">布尔值</i></font><b>;</b></p>
    <p _msttexthash="4812949648" _msthash="222">当 defer_foreign_keys <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#syntax" _istranslated="1">PRAGMA</a> 处于打开状态时，
 所有<a href="https://www.sqlite.org/foreignkeys.html" _istranslated="1">外键约束</a>的实施都会延迟到
 提交最外层的事务。defer_foreign_keys 编译指示
 默认为 OFF，以便仅在
 它们被创建为“DEFERRABLE INITIALLY DEFERRED”。这
 defer_foreign_keys pragma 在每个
 COMMIT 或 ROLLBACK 的 ROLLBACK 进行验证。因此，defer_foreign_keys pragma 必须是
 为每个事务单独启用。此 pragma 是
 当然，只有在启用外键约束时才有意义。</p>

    <p _msttexthash="950131260" _msthash="223"><a href="https://www.sqlite.org/c3ref/db_status.html" _istranslated="1">sqlite3_db_status</a>（<a href="https://www.sqlite.org/c3ref/c_dbstatus_options.html#sqlitedbstatusdeferredfks" _istranslated="1">db，SQLITE_DBSTATUS_DEFERRED_FKS</a>,...）
 在事务期间可以使用 C 语言接口来确定
 如果存在延迟和未解析的外键约束。</p>
<a name="pragma_empty_result_callbacks"></a>
<h _id="pragma_empty_result_callbacks" style="display:none" _msttexthash="767039" _msthidden="1" _msthash="224"> PRAGMA empty_result_callbacks</h><hr>
    <p><font _mstmutation="1" _msttexthash="61114482" _msthash="225"><b _mstmutation="1" _istranslated="1">PRAGMA empty_result_callbacks;<br _istranslated="1">PRAGMA empty_result_callbacks = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="45556394" _msthash="226">查询或更改 empty-result-callbacks 标志。</p>

    <p _msttexthash="5489647254" _msthash="227">empty-result-callbacks 标志仅影响 <a href="https://www.sqlite.org/c3ref/exec.html" _istranslated="1">sqlite3_exec（）</a> API。
 通常，当 empty-result-callbacks 标志被清除时，
 未调用提供给 <a href="https://www.sqlite.org/c3ref/exec.html" _istranslated="1">sqlite3_exec（）</a> 的回调函数
 对于返回零行数据的命令。当 empty-result-callbacks
 设置，则回调函数只调用一次，
 第三个参数设置为 0 （NULL）。这是为了启用程序
 使用 <a href="https://www.sqlite.org/c3ref/exec.html" _istranslated="1">sqlite3_exec（）</a> API 来检索列名，即使
 查询不返回任何数据。</p>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="228"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_encoding"></a>
<h _id="pragma_encoding" style="display:none" _msttexthash="233896" _msthidden="1" _msthash="229"> PRAGMA encoding</h><hr>
   <p><b _msttexthash="176204171" _msthash="230">PRAGMA 编码;<br _istranslated="1">PRAGMA 编码 = 'UTF-8';<br _istranslated="1">PRAGMA 编码 = 'UTF-16';<br _istranslated="1">PRAGMA 编码 = 'UTF-16le';<br _istranslated="1">PRAGMA 编码 = 'UTF-16be';</b></p>
    <p _msttexthash="2790184111" _msthash="231">在第一种形式中，如果主数据库已经
 created，则此 pragma 返回
 main 数据库，'UTF-8'、'UTF-16le' 之一（小端 UTF-16
 encoding） 或 'UTF-16be' （big-endian UTF-16 编码）。如果主
 database 尚未创建，则返回的值为
 将用于创建主数据库的文本编码，如果
 它由此会话创建。</p>

    <p _msttexthash="3167957533" _msthash="232">此编译指示的第二种到第五种形式
 设置创建主数据库时使用的编码 if
 它由此会话创建。字符串 'UTF-16' 被解释
 作为 “UTF-16 encoding using native machine byte-ordering” 进行编码。事实并非如此
 可以在数据库的文本编码后更改数据库的文本编码
 created 的，并且任何这样做的尝试都将被静默忽略。</p>

    <p _msttexthash="536044444" _msthash="233">如果首先未使用此 pragma 设置编码，则
 然后是创建主数据库时使用的编码
 默认为由<a href="https://www.sqlite.org/c3ref/open.html" _istranslated="1">用于打开连接的 API 确定的 API</a>。</p>

    <p _msttexthash="109208970" _msthash="234">一旦为数据库设置了编码，就无法更改它。</p>

    <p _msttexthash="637622102" _msthash="235">由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html" _istranslated="1">ATTACH</a> 命令创建的数据库始终使用相同的编码
 作为主数据库。尝试将数据库<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html" _istranslated="1">与</a>不同的
 来自 “main” 数据库的文本编码将失败。</p>
<a name="pragma_foreign_key_check"></a>
<h _id="pragma_foreign_key_check" style="display:none" _msttexthash="536718" _msthidden="1" _msthash="236"> PRAGMA foreign_key_check</h><hr>
    <p><font _mstmutation="1" _msttexthash="144320904" _msthash="237"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">foreign_key_check;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">foreign_key_check（</b><i _mstmutation="1" _istranslated="1">表名</i></font><b>);</b></p>

    <p _msttexthash="7553128245" _msthash="238">foreign_key_check pragma 检查数据库或表
 称为 “<i _istranslated="1">table-name</i>”，用于违反的<a href="https://www.sqlite.org/foreignkeys.html" _istranslated="1">外键约束</a>。foreign_key_check
 pragma 为每个外键冲突返回一行输出。
 每个结果行中有四列。
 第一列是包含 REFERENCES 的表的名称
 第。第二列是<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#rowid" _istranslated="1"></a>
 包含无效的 REFERENCES 子句，如果子表是 <a href="https://www.sqlite.org/withoutrowid.html" _istranslated="1">WITHOUT ROWID</a> 表，则为 NULL。第三列是名称
 的表。第四列是
 失败的特定外键约束。第四列
 在 foreign_key_check pragma 的输出中是与
 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_foreign_key_list" _istranslated="1">foreign_key_list pragma</a> 输出中的第一列。
 指定 “<i _istranslated="1">table-name</i>” 时，唯一的外键约束
 checked 是由
 CREATE TABLE <i _istranslated="1">语句。</i></p>
<a name="pragma_foreign_key_list"></a>
<h _id="pragma_foreign_key_list" style="display:none" _msttexthash="510744" _msthidden="1" _msthash="239"> PRAGMA foreign_key_list</h><hr>
    <p><font _mstmutation="1" _msttexthash="74574695" _msthash="240"><b _mstmutation="1" _istranslated="1">PRAGMA foreign_key_list（</b><i _mstmutation="1" _istranslated="1">表名</i>）</font><b>);</b></p>

    <p><font _mstmutation="1" _msttexthash="370357364" _msthash="241">此编译指示为由 CREATE TABLE 语句中的 REFERENCES 子句创建的每个<a href="https://www.sqlite.org/foreignkeys.html" _mstmutation="1" _istranslated="1">外键约束</a>返回一行
 表 “<i _mstmutation="1" _istranslated="1">table-name</i>” 的</font><a name="pragma_foreign_keys"></a>
<h _id="pragma_foreign_keys" style="display:none" _msttexthash="363805" _msthidden="1" _msthash="242"> PRAGMA foreign_keys</h></p><hr>
     <p><font _mstmutation="1" _msttexthash="41932943" _msthash="243"><b _mstmutation="1" _istranslated="1">PRAGMA foreign_keys;<br _istranslated="1">PRAGMA foreign_keys = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="82547530" _msthash="244">查询、设置或清除<a href="https://www.sqlite.org/foreignkeys.html" _istranslated="1">外键约束</a>的实施。</p><p _msttexthash="442117039" _msthash="245">此 pragma 是事务中的 no-op;外键约束
 只有在没有待处理的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_transaction.html" _istranslated="1">BEGIN</a> 或 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_savepoint.html" _istranslated="1">SAVEPOINT</a> 时，才能启用或禁用强制。</p><p _msttexthash="1592655753" _msthash="246">更改 foreign_keys 设置会影响
 所有报表均已准备就绪
 使用数据库连接，包括在
 设置已更改。使用旧版 <a href="https://www.sqlite.org/c3ref/prepare.html" _istranslated="1">sqlite3_prepare（）</a> 接口准备的任何现有语句都可能失败，并显示 <a href="https://www.sqlite.org/rescode.html#schema" _istranslated="1">SQLITE_SCHEMA</a> 错误
 更改 foreign_keys 设置后。</p><p><font _mstmutation="1" _msttexthash="3915862288" _msthash="247">从 SQLite <a href="https://www.sqlite.org/releaselog/3_6_19.html" _mstmutation="1" _istranslated="1">版本 3.6.19</a> 开始，外部的默认设置
 密钥强制为 OFF。但是，这种情况将来可能会改变
 发布 SQLite 的外键强制实施的默认设置
 可以在编译时使用 <a href="https://www.sqlite.org/compile.html#default_foreign_keys" _mstmutation="1" _istranslated="1">SQLITE_DEFAULT_FOREIGN_KEYS</a> 预处理器宏指定。为了最大限度地减少将来的问题，应用程序应该
 根据应用程序的要求设置外键实施标志
 ，不依赖于默认设置。</font><a name="pragma_freelist_count"></a>
<h _id="pragma_freelist_count" style="display:none" _msttexthash="438386" _msthidden="1" _msthash="248"> PRAGMA freelist_count</h></p><hr>
    <p _msttexthash="12226786" _msthash="249"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">freelist_count;</b></p>
    <p _msttexthash="69443712" _msthash="250">返回数据库文件中未使用的页数。</p>
<a name="pragma_full_column_names"></a>
<h _id="pragma_full_column_names" style="display:none" _msttexthash="548067" _msthidden="1" _msthash="251"> PRAGMA full_column_names</h><hr>
    <p><font _mstmutation="1" _msttexthash="51452739" _msthash="252"><b _mstmutation="1" _istranslated="1">PRAGMA full_column_names;<br _istranslated="1">PRAGMA full_column_names = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="1311281192" _msthash="253">查询或更改 full_column_names 标志。这面旗帜一起
 使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_short_column_names" _istranslated="1">short_column_names</a> 标志确定
 SQLite 为 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_select.html" _istranslated="1">SELECT</a> 语句的结果列分配名称的方式。
 结果列通过按顺序应用以下规则来命名：</p><ol>
    <li><p _msttexthash="113083009" _msthash="254">如果结果上有 AS 子句，则
 该列是 AS 子句的右侧。</p></li>
    <li><p _msttexthash="301304146" _msthash="255">如果结果是通用表达式，而不仅仅是
 源表列
 则结果的名称是表达式文本的副本。</p></li>
    <li><p _msttexthash="415276446" _msthash="256">如果 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_short_column_names" _istranslated="1">short_column_names</a> pragma 为 ON，则
 result 是源表列的名称，没有
 源表名前缀：COLUMN。</p></li>
    <li><p _msttexthash="317431738" _msthash="257">如果编译指示 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_short_column_names" _istranslated="1">short_column_names</a> 和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_full_column_names" _istranslated="1">full_column_names</a> 均为 OFF，则情况 （2） 适用。</p></li>
    <li><p _msttexthash="95453540" _msthash="258">结果列的名称是源表
 和源列名称：TABLE。列</p></li>
    </ol>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="259"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_fullfsync"></a>
<h _id="pragma_fullfsync" style="display:none" _msttexthash="270816" _msthidden="1" _msthash="260"> PRAGMA fullfsync</h><hr>
    <p><font _mstmutation="1" _msttexthash="35369165" _msthash="261"><b _mstmutation="1" _istranslated="1">PRAGMA fullfsync <br _istranslated="1">PRAGMA fullfsync = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="702597454" _msthash="262">查询或更改 fullfsync 标志。此标志
 确定是否使用 F_FULLFSYNC 同步方法
 在支持它的系统上。fullfsync 标志的默认值
 已关闭。只有 Mac OS X 支持 F_FULLFSYNC。</p>

    <p _msttexthash="18300867" _msthash="263">另请参见 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_checkpoint_fullfsync" _istranslated="1">checkpoint_fullfsync</a>。</p>
<a name="pragma_function_list"></a>
<h _id="pragma_function_list" style="display:none" _msttexthash="402389" _msthidden="1" _msthash="264"> PRAGMA function_list</h><hr>
    <p><b _msttexthash="422331" _msthash="265">PRAGMA function_list;</b>
    </p><p><font _mstmutation="1" _msttexthash="1695646914" _msthash="266">此编译指示返回 SQL 函数列表
 数据库连接已知。结果的每一行
 描述单个 SQL 函数的单个调用签名。
 某些 SQL 函数在结果集中将具有多行
 如果它们可以（例如）使用不同数量的
 参数，也可以接受各种编码的文本。</font><a name="pragma_hard_heap_limit"></a>
<h _id="pragma_hard_heap_limit" style="display:none" _msttexthash="461981" _msthidden="1" _msthash="267"> PRAGMA hard_heap_limit</h></p><hr>
    <p _msttexthash="1560065" _msthash="268"><b>PRAGMA hard_heap_limit<br>
          PRAGMA hard_heap_limit=</b><i>N</i></p>

    <p _msttexthash="3502856565" _msthash="269">此编译指示<a href="https://www.sqlite.org/c3ref/hard_heap_limit64.html" _istranslated="1">sqlite3_hard_heap_limit64</a>使用
 参数 N，如果指定了 N 且 N 是一个正整数，则
 小于当前硬堆限制。
 hard_heap_limit pragma 始终返回相同的整数
 将由 <a href="https://www.sqlite.org/c3ref/hard_heap_limit64.html" _istranslated="1">sqlite3_hard_heap_limit64</a>（-1） C 语言返回
 功能。也就是说，它总是返回 hard 的值
 堆限制，该限制是在此 PRAGMA 施加的任何更改之后设置的。</p>

    <p _msttexthash="525627778" _msthash="270">这个 pragma 只能降低堆限制，永远不能提高它。
 必须使用 C 语言接口 <a href="https://www.sqlite.org/c3ref/hard_heap_limit64.html" _istranslated="1">sqlite3_hard_heap_limit64（）</a>
 以提高堆限制。</p>

    <p><font _mstmutation="1" _msttexthash="18492552" _msthash="271">另请参见 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_soft_heap_limit" _mstmutation="1" _istranslated="1">soft_heap_limit pragma</a>。</font><a name="pragma_ignore_check_constraints"></a>
<h _id="pragma_ignore_check_constraints" style="display:none" _msttexthash="871611" _msthidden="1" _msthash="272"> PRAGMA ignore_check_constraints</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="35421854" _msthash="273"><b _mstmutation="1" _istranslated="1">PRAGMA ignore_check_constraints = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="428589941" _msthash="274">此 pragma 启用或禁用 CHECK 约束的实施。
 默认设置为 off，这意味着 CHECK 约束为
 默认强制执行。</p>
<a name="pragma_incremental_vacuum"></a>
<h _id="pragma_incremental_vacuum" style="display:none" _msttexthash="592384" _msthidden="1" _msthash="275"> PRAGMA incremental_vacuum</h><hr>
    <p _msttexthash="111557862" _msthash="276"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">incremental_vacuum</b><i _istranslated="1">（N）</i><b _istranslated="1">;<br _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">incremental_vacuum;</b></p>
    <p _msttexthash="3768013600" _msthash="277">incremental_vacuum 编译指示会导致最多 <i _istranslated="1">N</i> 个页面
 从<a href="https://www.sqlite.org/fileformat2.html#freelist" _istranslated="1">空闲列表中</a>删除。数据库文件被截断
 相同的数量。如果 incremental_vacuum pragma 在
 数据库未处于 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_auto_vacuum" _istranslated="1">auto_vacuum=增量</a>模式
 或者如果空闲列表中没有页面。如果空闲列表中的页面少于 <i _istranslated="1">N</i>，或者 <i _istranslated="1">N</i> 小于 1，或者
 如果省略 “（<i _istranslated="1">N</i>）” 参数，则整个
 freelist 被清除。</p>
<a name="pragma_index_info"></a>
<h _id="pragma_index_info" style="display:none" _msttexthash="294944" _msthidden="1" _msthash="278"> PRAGMA index_info</h><hr>
    <p><font _mstmutation="1" _msttexthash="74500296" _msthash="279"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">index_info（</b><i _mstmutation="1" _istranslated="1">索引名称</i></font><b>);</b></p>
    <p _msttexthash="2568266922" _msthash="280">此 pragma 为命名索引中的每个键列返回一行。
 键列是在 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1">CREATE INDEX</a> 索引语句或 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#uniqueconst" _istranslated="1">UNIQUE 约束</a>或 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#primkeyconst" _istranslated="1">PRIMARY KEY 约束</a>中实际命名的列，该
 创建了索引。索引条目通常也包含 auxiliary
 列，这些列指向正在编制索引的表行。辅助
 index-columns 不由 index_info pragma 显示，但它们是
 由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_index_xinfo" _istranslated="1">index_xinfo pragma</a> 列出。</p>

    <p _msttexthash="98000006" _msthash="281">index_info pragma 的输出列如下所示：</p><ol>
    <li _msttexthash="74273121" _msthash="282">索引中列的排名。（0 表示最左侧。</li><li _msttexthash="275868853" _msthash="283">正在编制索引的表中的列的排名。
 值 -1 表示 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#rowid" _istranslated="1">rowid</a>，值 -2 表示正在使用<a href="https://www.sqlite.org/expridx.html" _istranslated="1">表达式</a>。</li><li _msttexthash="184173834" _msthash="284">正在编制索引的列的名称。此列为 NULL
 如果列是 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#rowid" _istranslated="1">rowid</a> 还是<a href="https://www.sqlite.org/expridx.html" _istranslated="1">表达式</a>。</li></ol>

    <p><font _mstmutation="1" _msttexthash="1708164601" _msthash="285">如果没有名为 <i _mstmutation="1" _istranslated="1">index-name</i> 的索引，但存在具有该名称的 <a href="https://www.sqlite.org/withoutrowid.html" _mstmutation="1" _istranslated="1">WITHOUT ROWID</a> 表，则 （截至
 SQLite <a href="https://www.sqlite.org/releaselog/3_30_0.html" _mstmutation="1" _istranslated="1">版本 3.30.0</a> 在 2019-10-04）此编译指示返回
 PRIMARY KEY 列
 在底层 B 树的记录中，也就是说，使用
 删除了重复的列。</font><a name="pragma_index_list"></a>
<h _id="pragma_index_list" style="display:none" _msttexthash="299364" _msthidden="1" _msthash="286"> PRAGMA index_list</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="78818194" _msthash="287"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">index_list（</b><i _mstmutation="1" _istranslated="1">表名）</i></font><b>);</b></p>
    <p _msttexthash="51694331" _msthash="288">此编译指示为与
 给定的表。</p><p _msttexthash="98003178" _msthash="289">index_list pragma 的输出列如下所示：</p><ol>
    <li _msttexthash="127638888" _msthash="290">分配给每个索引以进行内部跟踪的序列号
 目的。</li><li _msttexthash="18174676" _msthash="291">索引的名称。</li><li _msttexthash="97774950" _msthash="292">如果索引为 UNIQUE，则为 “1”，否则为 “0”。</li><li _msttexthash="919209096" _msthash="293">如果索引是由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1">CREATE INDEX</a> 语句创建的，则为 “c”，
 如果索引是由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#uniqueconst" _istranslated="1">UNIQUE 约束</a>创建的，则为 “u”，或者
 如果索引是由 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#primkeyconst" _istranslated="1">PRIMARY KEY 约束</a>创建的，则为 “pk”。</li><li _msttexthash="161778851" _msthash="294">如果索引是<a href="https://www.sqlite.org/partialindex.html" _istranslated="1">部分索引</a>，则为 “1”，如果不是，则为 “0”。</li></ol>
    <p></p>
<a name="pragma_index_xinfo"></a>
<h _id="pragma_index_xinfo" style="display:none" _msttexthash="330148" _msthidden="1" _msthash="295"> PRAGMA index_xinfo</h><hr>
    <p><font _mstmutation="1" _msttexthash="103967552" _msthash="296"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">index_xinfo（</b><i _mstmutation="1" _istranslated="1">索引名称）</i></font><b>);</b></p>
    <p _msttexthash="2818643893" _msthash="297">此 pragma 返回有关索引中每一列的信息。
 与此 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_index_info" _istranslated="1">index_info pragma</a> 不同，此 pragma 返回有关
 索引中的每一列，而不仅仅是键列。
 （键列是在 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1">CREATE INDEX</a> 索引语句或 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#uniqueconst" _istranslated="1">UNIQUE 约束</a>或 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#primkeyconst" _istranslated="1">PRIMARY KEY 约束</a>中实际命名的列，该
 创建了索引。辅助列是
 找到与每个索引条目对应的表条目。</p><p _msttexthash="101589319" _msthash="298">index_xinfo pragma 的输出列如下所示：</p><ol>
    <li _msttexthash="155585183" _msthash="299">索引中列的排名。（0 表示最左侧。
 键列位于辅助列之前。</li><li _msttexthash="640214120" _msthash="300">正在编制索引的表中列的排名，如果为 -1，则为 -1
 index-column 是要编制索引的 table 的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#rowid" _istranslated="1">rowId</a>，并且是 -2
 如果<a href="https://www.sqlite.org/expridx.html" _istranslated="1">索引位于表达式上</a>。</li><li _msttexthash="305148532" _msthash="301">正在编制索引的列的名称，如果索引列为 NULL
 是正在编制索引的表的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#rowid" _istranslated="1">rowid</a> 或<a href="https://www.sqlite.org/expridx.html" _istranslated="1">表达式</a>。</li><li _msttexthash="62762284" _msthash="302">如果索引列按
 index 和 0，否则为 0。</li><li _msttexthash="122724745" _msthash="303">用于比较 index-column 中的值的<a href="https://www.sqlite.org/datatype3.html#collation" _istranslated="1">整理序列</a>的名称。</li><li _msttexthash="155371918" _msthash="304">如果索引列是键列，则为 1，如果索引列为 0
 是辅助柱。</li></ol>

    <p><font _mstmutation="1" _msttexthash="1943746792" _msthash="305">如果没有名为 <i _mstmutation="1" _istranslated="1">index-name</i> 的索引，但存在具有该名称的 <a href="https://www.sqlite.org/withoutrowid.html" _mstmutation="1" _istranslated="1">WITHOUT ROWID</a> 表，则 （截至
 SQLite <a href="https://www.sqlite.org/releaselog/3_30_0.html" _mstmutation="1" _istranslated="1">版本 3.30.0</a> 在 2019-10-04）此编译指示返回
 列
 在底层 B 树的记录中，也就是说，使用
 首先删除重复的 PRIMARY KEY 列，然后是 data 列。</font><a name="pragma_integrity_check"></a>
<h _id="pragma_integrity_check" style="display:none" _msttexthash="466817" _msthidden="1" _msthash="306"> PRAGMA integrity_check</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="351111501" _msthash="307"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">integrity_check;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">integrity_check（</b><i _mstmutation="1" _istranslated="1">N</i><b _mstmutation="1" _istranslated="1">） <br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">integrity_check（</b><i _mstmutation="1" _istranslated="1">TABLENAME）</i></font><b>)</b></p>
    <p _msttexthash="235880450" _msthash="308">此 pragma 执行低级格式设置和一致性检查
 的数据库。integrity_check pragma 查找：</p><ul>
    <li _msttexthash="44279586" _msthash="309">顺序不序的表或索引项</li><li _msttexthash="28123472" _msthash="310">格式错误的记录</li><li _msttexthash="19503874" _msthash="311">缺失的页面</li><li _msttexthash="39176124" _msthash="312">索引条目缺失或超额</li><li _msttexthash="57093127" _msthash="313">UNIQUE、CHECK 和 NOT NULL 约束错误</li><li _msttexthash="29516084" _msthash="314">免费列表的完整性</li><li _msttexthash="143861380" _msthash="315">数据库的多个部分被多次使用，或者根本不被使用</li></ul>
    <p _msttexthash="2243966777" _msthash="316">如果 integrity_check 杂注发现问题，则返回字符串
 （作为多行，每行一列），其中描述
 问题。在分析退出之前，Pragma integrity_check 将最多返回 <i _istranslated="1">N</i> 个错误，其中 N 默认为 N
 设置为 100。如果 pragma integrity_check 未找到错误，则
 返回值为 'ok' 的单行。</p>

    <p _msttexthash="4201412176" _msthash="317">通常的情况是检查整个数据库文件。然而
 如果参数为 <i _istranslated="1">TABLENAME</i>，则仅对
 名为 的表及其关联的索引。
 这称为 “部分完整性检查”。因为只有
 数据库，则错误包括文件未使用的部分或重复
 无法检测到两个或多个表对文件的同一部分的使用。
 空闲列表仅在
 部分完整性检查 <i _istranslated="1">TABLENAME</i> 是否<a href="https://www.sqlite.org/schematab.html" _istranslated="1">为 sqlite_schema</a> 或其
 别名。添加了对部分完整性检查的支持
 版本 3.33.0 （2020-08-14）。</p><p _msttexthash="267503080" _msthash="318">PRAGMA integrity_check 找不到 <a href="https://www.sqlite.org/foreignkeys.html" _istranslated="1">FOREIGN KEY</a> 错误。
 使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_foreign_key_check" _istranslated="1">PRAGMA foreign_key_check</a> 命令查找
 FOREIGN KEY 约束。</p>

    <p _msttexthash="415253865" _msthash="319">另请参阅 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_quick_check" _istranslated="1">PRAGMA quick_check</a> 命令，该命令执行大部分
 检查 PRAGMA integrity_check但运行速度要快得多。</p>
<a name="pragma_journal_mode"></a>
<h _id="pragma_journal_mode" style="display:none" _msttexthash="359736" _msthidden="1" _msthash="320"> PRAGMA journal_mode</h><hr>
    <p _msttexthash="277728516" _msthash="321"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">journal_mode;<br _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">journal_mode
 = <i _istranslated="1">删除 |截断 |持久化 |内存 |瓦尔 |离</i></b></p>

    <p _msttexthash="208147173" _msthash="322">此 pragma 查询或设置数据库的日志模式
 与当前<a href="https://www.sqlite.org/c3ref/sqlite3.html" _istranslated="1">数据库连接</a>关联。</p>

    <p _msttexthash="347738963" _msthash="323">此 pragma 的第一种形式查询当前日记
 mode 的<i _istranslated="1">数据库</i>。当省略 <i _istranslated="1">database</i> 时，
 查询 “main” 数据库。</p>

    <p _msttexthash="1196237146" _msthash="324">第二种形式更改了 “<i _istranslated="1">database</i>” 的日记模式
 或者，如果省略了 “<i _istranslated="1">database</i>”，则为所有附加的数据库。
 返回新的日志模式。如果日志模式
 无法更改，则返回原始日志模式。</p>

    <p _msttexthash="1323695802" _msthash="325">DELETE 日记模式是正常行为。在 DELETE
 模式中，回滚日志将在每个
 交易。事实上，删除作是导致
 要提交的事务。
 （有关更多详细信息，请参阅标题<a href="https://www.sqlite.org/atomiccommit.html" _istranslated="1">为“SQLite 中的原子提交</a>”的文档。</p>

    <p _msttexthash="1121696654" _msthash="326">TRUNCATE 日志记录模式通过截断
 将 rollback 日志恢复为零长度，而不是将其删除。在许多
 系统，截断文件比删除文件要快得多，因为
 不需要更改包含目录。</p>

    <p _msttexthash="2337865868" _msthash="327">PERSIST 日志记录模式可防止回滚日志
 在每个事务结束时被删除。相反，标头
 的日志被零覆盖。这将防止其他
 数据库连接。坚持
 日志模式在以下平台上用作优化
 删除或截断文件比覆盖文件的成本要高得多
 具有 0 的文件的第一个块。另请参阅：<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_size_limit" _istranslated="1">PRAGMA journal_size_limit</a> 和 <a href="https://www.sqlite.org/compile.html#default_journal_size_limit" _istranslated="1">SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT</a>。</p>

    <p _msttexthash="1826719375" _msthash="328">MEMORY 日志记录模式将回滚日志存储在
 易失性 RAM。这样可以节省磁盘 I/O，但会牺牲数据库
 安全和诚信。如果使用 SQLite 的应用程序崩溃
 设置了 MEMORY 日志记录模式时，事务的中间，
 那么数据库文件很可能会<a href="https://www.sqlite.org/howtocorrupt.html#cfgerr" _istranslated="1">损坏</a>。</p>

    <p _msttexthash="2193318517" _msthash="329">WAL 日志记录模式使用<a href="https://www.sqlite.org/wal.html" _istranslated="1">预写日志</a>，而不是
 rollback journal 来实现事务。WAL 日记模式
 是持久的;设置后，它将保持有效
 跨多个数据库连接以及关闭和
 重新打开数据库。处于 WAL 日记模式的数据库
 只能通过 SQLite <a href="https://www.sqlite.org/releaselog/3_7_0.html" _istranslated="1">版本 3.7.0</a> 访问 （2010-07-21）
 或之后。</p>

    <p _msttexthash="14270529988" _msthash="330">OFF 日志记录模式将完全禁用回滚日志。
 从未创建过回滚日志，因此永远不会有回滚
 要删除的日志。OFF 日志记录模式禁用原子
 SQLite 的提交和回滚功能。<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_transaction.html" _istranslated="1">ROLLBACK</a> 命令
 不再有效;它以未定义的方式运行。应用程序必须
 避免在日志模式为 OFF 时使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_transaction.html" _istranslated="1">ROLLBACK</a> 命令。
 如果应用程序崩溃
 在事务处理过程中，当 OFF 日记模式为
 set，则数据库文件很可能会<a href="https://www.sqlite.org/howtocorrupt.html#cfgerr" _istranslated="1">损坏</a>。没有日志，就没有办法
 用于展开部分完成的作的语句
 约束错误。这也可能使数据库处于损坏状态
 州。例如，如果重复的条目导致 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1">CREATE UNIQUE INDEX</a> 语句中途失败，
 它将留下一个部分创建的索引，因此会损坏。
 由于 OFF 日记
 mode 允许使用普通 SQL 损坏数据库文件，
 启用 <a href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive" _istranslated="1">SQLITE_DBCONFIG_DEFENSIVE</a> 时，它将被禁用。</p>

    <p _msttexthash="1648647416" _msthash="331">请注意，<a href="https://www.sqlite.org/inmemorydb.html" _istranslated="1">内存中数据库</a>的 journal_mode 为 MEMORY 或 OFF，不能更改为其他值。
 尝试将<a href="https://www.sqlite.org/inmemorydb.html" _istranslated="1">内存中数据库</a>的 journal_mode 更改为
 将忽略 MEMORY 或 OFF 以外的任何设置。另请注意，
 当事务处于活动状态时，无法更改 journal_mode。</p>
<a name="pragma_journal_size_limit"></a>
<h _id="pragma_journal_size_limit" style="display:none" _msttexthash="594971" _msthidden="1" _msthash="332"> PRAGMA journal_size_limit</h><hr>
    <p><font _mstmutation="1" _msttexthash="48634794" _msthash="333"><b _mstmutation="1" _istranslated="1"> PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1"><br _istranslated="1"> journal_size_limit PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">journal_size_limit = </b><i _mstmutation="1" _istranslated="1">N</i></font> <b>;</b>

  </p><p _msttexthash="4003974585" _msthash="334">如果数据库连接在<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_locking_mode" _istranslated="1">独占锁定模式</a>或<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_mode" _istranslated="1">持久日志模式</a> （PRAGMA journal_mode=persist） 下运行，则
 提交事务后，<a href="https://www.sqlite.org/lockingv3.html#rollback" _istranslated="1">回滚日志文件</a>可能保留在
 文件系统。这可以提高后续事务的性能
 由于覆盖现有文件比附加到文件更快，因此
 但它也会消耗
 文件系统空间。在大型事务（例如 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM）</a>之后，
 回滚日志文件可能会占用大量空间。</p><p _msttexthash="722571837" _msthash="335">同样，在 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 模式下</a>，预写日志文件不会被截断
 遵循<a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">检查点</a>。相反，SQLite 重用现有文件
 对于后续 WAL 条目，因为覆盖比附加更快。</p><p _msttexthash="3228055272" _msthash="336">journal_size_limit pragma 可用于限制
 留下的 rollback-journal 和 WAL 文件
 在文件系统中 transactions 或 checkpoints 之后。
 每次提交事务或 WAL 文件重置时，SQLite
 比较回滚日志文件或 WAL 文件的大小
 文件系统达到大小限制
 由此 pragma 设置，并且如果 journal 或 WAL 文件更大
 它被截断到限制。</p><p _msttexthash="5799279369" _msthash="337">上面列出的 pragma 的第二种形式用于设置新的限制
 以字节为单位。负数表示没有限制。
 要始终将回滚日志和 WAL 文件截断到其最小大小，
 将 journal_size_limit 设置为零。
 上面列出的 pragma 的第一种和第二种形式都返回一个
 包含单个整数列的结果行 - 日志的值
 大小限制（以字节为单位）。默认日志大小限制为 -1（无限制）。<a href="https://www.sqlite.org/compile.html#default_journal_size_limit" _istranslated="1">SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT</a> 预处理器宏可用于更改
 编译时的默认日志大小限制。</p>

  <p><font _mstmutation="1" _msttexthash="1889187625" _msthash="338">此 pragma 仅在之前指定的单个数据库上运行
 添加到 pragma 名称中（如果未指定数据库，则在 “main” 数据库上）。
 无法更改所有附加数据库的日志大小限制
 使用单个 PRAGMA 语句。必须单独设置大小限制
 每个附加的数据库。</font><a name="pragma_legacy_alter_table"></a>
<h _id="pragma_legacy_alter_table" style="display:none" _msttexthash="577902" _msthidden="1" _msthash="339"> PRAGMA legacy_alter_table</h></p><hr>
   <p><b _msttexthash="53337479" _msthash="340">PRAGMA legacy_alter_table;<br _istranslated="1">PRAGMA legacy_alter_table = <i _istranslated="1">布尔</i>值</b></p>
    <p _msttexthash="3218333209" _msthash="341">此 pragma 设置或查询 legacy_alter_table 的值
 旗。当此标志打开时，<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_altertable.html#altertabrename" _istranslated="1">ALTER TABLE RENAME</a> 命令（用于更改表的名称）将按原样工作
 在 SQLite 3.24.0 （2018-06-04） 及更早版本中。更具体地说，
 当此标志处于打开状态时
 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_altertable.html#altertabrename" _istranslated="1">ALTER TABLE RENAME</a> 命令仅重写初始出现
 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html" _istranslated="1">的表</a>名。<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1"></a> <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtrigger.html" _istranslated="1"></a>对
 table 的 ID 未修改，包括：</p><ul>
    <li _msttexthash="75730213" _msthash="342">对触发器和视图主体中的表的引用。</li><li _msttexthash="93844699" _msthash="343">对原始 CHECK 约束中的表的引用
 CREATE TABLE 语句。</li><li _msttexthash="83757492" _msthash="344"><a href="https://www.sqlite.org/partialindex.html" _istranslated="1">在部分索引</a>的 WHERE 子句中对表的引用。</li></ul><font _mstmutation="1" _msttexthash="401208561" _msthash="345">此 pragma 的默认设置为 OFF，这意味着所有
 对架构中任意位置的表的引用将转换为新名称。</font><p _msttexthash="1012136970" _msthash="346">此 pragma 是作为旧程序的解决方法提供的，这些程序
 包含预期 Incomplete 行为的代码
 在旧版本的 SQLite 中找到的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_altertable.html#altertabrename" _istranslated="1">ALTER TABLE RENAME</a>。
 新应用程序应将此标志保持关闭状态。</p><p _msttexthash="625678430" _msthash="347">为了与较旧的<a href="https://www.sqlite.org/vtab.html" _istranslated="1">虚拟 table</a> 实现兼容，
 此标志在运行 <a href="https://www.sqlite.org/vtab.html#xrename" _istranslated="1">sqlite3_module.xRename</a> 方法时临时打开。此标志的值在 <a href="https://www.sqlite.org/vtab.html#xrename" _istranslated="1">sqlite3_module.xRename</a> 方法完成后恢复。</p><p _msttexthash="389412803" _msthash="348">还可以打开和关闭传统的 alter table 行为
 使用 <a href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyaltertable" _istranslated="1">SQLITE_DBCONFIG_LEGACY_ALTER_TABLE</a> 选项到 <a href="https://www.sqlite.org/c3ref/db_config.html" _istranslated="1">sqlite3_db_config（）</a> 接口。</p><p><font _mstmutation="1" _msttexthash="1219901293" _msthash="349">旧版 alter table 行为是每个连接的设置。把
 此功能的 ON 或 OFF 会影响<a href="https://www.sqlite.org/c3ref/sqlite3.html" _mstmutation="1" _istranslated="1">数据库连接</a>中所有附加的数据库文件。
 该设置不会保留。在一个连接中更改此设置
 不会影响任何其他连接。</font><a name="pragma_legacy_file_format"></a>
<h _id="pragma_legacy_file_format" style="display:none" _msttexthash="582426" _msthidden="1" _msthash="350"> PRAGMA legacy_file_format</h></p><hr>
   <p><b _msttexthash="606203" _msthash="351">PRAGMA legacy_file_format;</b>
    </p><p _msttexthash="934954969" _msthash="352">此 pragma 不再起作用。它已经成为一个无作。
 以前由 PRAGMA legacy_file_format 提供的功能
 现在可以使用 <a href="https://www.sqlite.org/c3ref/db_config.html" _istranslated="1">sqlite3_db_config（）</a> C 语言界面的 <a href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfiglegacyfileformat" _istranslated="1">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT</a> 选项使用。</p><p _msthidden="1">
<a name="pragma_locking_mode"></a>
<h _id="pragma_locking_mode" style="display:none" _msttexthash="355810" _msthidden="1" _msthash="353"> PRAGMA locking_mode</h></p><hr>
    <p _msttexthash="115513801" _msthash="354"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">locking_mode;<br _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">locking_mode
 = <i _istranslated="1">正常 |独家</i></b></p>
    <p _msttexthash="189322367" _msthash="355">此 pragma 设置或查询数据库连接锁定模式。
 锁定模式为 NORMAL 或 EXCLUSIVE。</p><p _msttexthash="4661538323" _msthash="356">在 NORMAL 锁定模式下（除非在编译时覆盖，否则为默认值
 使用 <a href="https://www.sqlite.org/compile.html#default_locking_mode" _istranslated="1">SQLITE_DEFAULT_LOCKING_MODE</a>）、数据库连接
 在每次读取结束时解锁数据库文件，或者
 写入事务。当 locking-mode 设置为 EXCLUSIVE 时，
 数据库连接从不释放文件锁。第一次使用
 database 在 EXCLUSIVE 模式下读取，则获取共享锁，并且
 举行。第一次写入数据库时，排他锁是
 获得并持有。</p>

    <p _msttexthash="2117090846" _msthash="357">在 EXCLUSIVE 模式下，连接获取的数据库锁可以是
 通过关闭数据库连接或设置
 locking-mode 返回为 NORMAL，然后访问
 数据库文件（用于读取或写入）。只需将锁定模式设置为
 NORMAL 是不够的 - 直到下次才释放锁
 访问数据库文件。</p>

    <p _msttexthash="95215120" _msthash="358">将 locking-mode 设置为 EXCLUSIVE 的原因有三个。</p><ol>
    <li _msttexthash="114158759" _msthash="359">应用程序希望阻止其他进程
 访问数据库文件。</li><li _msttexthash="201451289" _msthash="360">文件系统作的系统调用次数减少，
 可能会导致性能略有提高。</li><li><font _mstmutation="1" _msttexthash="294568911" _msthash="361"><a href="https://www.sqlite.org/wal.html" _mstmutation="1" _istranslated="1">WAL</a> 数据库可以在 EXCLUSIVE 模式下访问，而无需
 使用共享内存。
 （<a href="https://www.sqlite.org/wal.html#noshm" _mstmutation="1" _istranslated="1">其他信息</a></font>)
    </li></ol>
    <p></p>

    <p _msttexthash="160847609" _msthash="362">当 locking_mode pragma 指定特定数据库时，
 例如：</p>

    <blockquote _msttexthash="19244524" _msthash="363">PRAGMA <b _istranslated="1">main.</b>locking_mode=排他;</blockquote>

    <p _msttexthash="1057937491" _msthash="364">则锁定模式仅适用于命名数据库。如果没有
 数据库名称限定符位于 “locking_mode” 关键字之前
 锁定模式适用于所有数据库，包括任何新的
 由后续 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html" _istranslated="1">ATTACH</a> 命令添加的数据库。</p>

   <p _msttexthash="1551336657" _msthash="365">“temp” 数据库（其中存储了 TEMP 表和索引）
 <a href="https://www.sqlite.org/inmemorydb.html" _istranslated="1">内存数据库</a>始终使用独占锁定模式。临时<a href="https://www.sqlite.org/inmemorydb.html" _istranslated="1">数据库和内存数据库</a>的锁定模式不能
 被更改。默认情况下，所有其他数据库都使用正常锁定模式
 并受此 pragma 影响。</p>

   <p _msttexthash="1847039701" _msthash="366">如果在首次进入 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 日志模式</a>时锁定模式为 EXCLUSIVE，则不能将锁定模式更改为
 NORMAL 直到退出 WAL 日志模式之后。
 如果首次进入 WAL 时锁定模式为 NORMAL
 journal 模式，则可以在 NORMAL 和
 EXCLUSIVE 并随时返回，无需退出
 WAL 日志模式。</p>
<a name="pragma_max_page_count"></a>
<h _id="pragma_max_page_count" style="display:none" _msttexthash="431080" _msthidden="1" _msthash="367"> PRAGMA max_page_count</h><hr>
    <p><font _mstmutation="1" _msttexthash="45498102" _msthash="368"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">max_page_count;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">max_page_count = </b><i _mstmutation="1" _istranslated="1">N</i></font><b>;</b></p>
    <p _msttexthash="863271240" _msthash="369">查询或设置数据库文件中的最大页数。
 两种形式的 pragma 都返回最大页数。第二个
 form 尝试修改最大页数。最大页数
 count 不能减少到当前数据库大小以下。</p>
<a name="pragma_mmap_size"></a>
<h _id="pragma_mmap_size" style="display:none" _msttexthash="267397" _msthidden="1" _msthash="370"> PRAGMA mmap_size</h><hr>
    <p><br><font _mstmutation="1" _msttexthash="40608776" _msthash="371"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">mmap_size;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">mmap_size=</b><i _mstmutation="1" _istranslated="1">N</i></font></p>

    <p _msttexthash="4263357371" _msthash="372">查询或更改设置的最大字节数
 除了单个数据库上的内存映射 I/O 之外。第一种形式
 （不带参数）查询当前限制。第二个
 form （带有 numeric 参数）设置指定
 database，或者对于所有数据库（如果可选数据库名称为
 省略。在第二种形式中，如果省略数据库名称，则
 limit 将成为所有数据库的默认限制
 通过后续 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html" _istranslated="1">ATTACH</a> 语句添加到<a href="https://www.sqlite.org/c3ref/sqlite3.html" _istranslated="1">数据库连接</a>中。</p>

    <p _msttexthash="2490398001" _msthash="373">参数 N 是数据库文件的最大字节数
 ，这将使用内存映射 I/O 进行访问。如果 N 为零，则
 内存映射 I/O 已禁用。如果 N 为负数，则限制
 恢复到由最近的 <a href="https://www.sqlite.org/c3ref/config.html" _istranslated="1">sqlite3_config</a> （<a href="https://www.sqlite.org/c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize" _istranslated="1">SQLITE_CONFIG_MMAP_SIZE</a>） 确定的默认值，或恢复到 Compile
 时间默认值由 <a href="https://www.sqlite.org/compile.html#default_mmap_size" _istranslated="1">SQLITE_DEFAULT_MMAP_SIZE</a> 确定，否则
 start-time limit 已设置。</p>

    <p><font _mstmutation="1" _msttexthash="1044724200" _msthash="374"><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_mmap_size" _mstmutation="1" _istranslated="1">PRAGMA mmap_size</a> 语句永远不会增加金额
 用于内存映射 I/O 的地址空间高于
 由 <a href="https://www.sqlite.org/compile.html#max_mmap_size" _mstmutation="1" _istranslated="1">SQLITE_MAX_MMAP_SIZE</a> 编译时选项设置的 hard limit，
 也不是 startup-time 由第二个参数为
 sqlite3_config（<a href="https://www.sqlite.org/c3ref/c_config_covering_index_scan.html#sqliteconfigmmapsize" _mstmutation="1" _istranslated="1">SQLITE_CONFIG_MMAP_SIZE</a></font>)</p>

    <p _msttexthash="1739066849" _msthash="375">内存映射 I/O 区域的大小不能更改，而
 内存映射的 I/O 区域正在使用中，以避免取消映射
 内存不足。因此，
 如果 mmap_size 编译指示的前mmap_size非零，则 pragma 可能是 no-op
 并且有其他 SQL 语句在同一<a href="https://www.sqlite.org/c3ref/sqlite3.html" _istranslated="1">数据库连接</a>上并发运行。</p>
<a name="pragma_module_list"></a>
<h _id="pragma_module_list" style="display:none" _msttexthash="331539" _msthidden="1" _msthash="376"> PRAGMA module_list</h><hr>
    <p><b _msttexthash="349947" _msthash="377">PRAGMA module_list;</b>
    </p><p><font _mstmutation="1" _msttexthash="167577553" _msthash="378">此编译指示返回向数据库连接注册的<a href="https://www.sqlite.org/vtab.html" _mstmutation="1" _istranslated="1">虚拟表</a>模块的列表。</font><a name="pragma_optimize"></a>
<h _id="pragma_optimize" style="display:none" _msttexthash="242450" _msthidden="1" _msthash="379"> PRAGMA optimize</h></p><hr>
  <p><font _mstmutation="1" _msttexthash="199138992" _msthash="380"><b _mstmutation="1" _istranslated="1">PRAGMA 优化;<br _istranslated="1">PRAGMA 优化（</b><i _mstmutation="1" _istranslated="1">掩码）;</i><b _mstmutation="1" _istranslated="1"><br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1"></i><b _mstmutation="1" _istranslated="1">schema.optimize;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1"></i><b _mstmutation="1" _istranslated="1">schema.optimize（</b><i _mstmutation="1" _istranslated="1">掩码</i></font><b>);</b></p>
  <p _msttexthash="392311166" _msthash="381">尝试优化数据库。所有 schema 都在
 前两种形式，并且只有指定的架构在后一种形式中得到优化
 二。</p>
  <p _msttexthash="394781036" _msthash="382">在大多数应用程序中，按如下方式使用 PRAGMA optimize 会有所帮助
 SQLite 来实现最佳的查询性能：</p><ol>
  <li><p _msttexthash="389537902" _msthash="383">具有短期数据库连接的应用程序应运行
 “PRAGMA optimize;” 一次，就在关闭每个数据库连接之前。</p></li><li><p _msttexthash="898040910" _msthash="384">使用长期数据库连接的应用程序应运行
 “PRAGMA optimize=0x10002;” 首次打开连接时，然后
 还定期运行 “PRAGMA optimize;”，可能每天一次或一次
 每小时。</p></li><li><p _msttexthash="334065017" _msthash="385">所有应用程序都应在架构更改后运行 “PRAGMA optimize;”，
 尤其是在一个或多个 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1">CREATE INDEX</a> 语句之后。</p></li></ol>
  <p _msttexthash="1239769271" _msthash="386">此 pragma 通常是 no-op 或几乎是 no-op，并且非常快。在
 确实需要在一个或多个表上运行 ANALYZE 时，它会
 设置临时<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_analysis_limit" _istranslated="1">分析限</a>值，在持续时间内有效
 ，这会阻止
 到长。</p>
  <p _msttexthash="2700091680" _msthash="387">建议的做法是，具有短期数据库的应用程序
 当数据库连接时，连接应运行一次 “PRAGMA optimize”
 关闭。具有长期数据库连接的应用程序应运行
 “PRAGMA optimize=0x10002”，然后
 定期再次运行 “PRAGMA optimize” - 可能每天一次。
 所有应用程序都应在架构更改后运行 “PRAGMA optimize”，尤其是 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createindex.html" _istranslated="1">CREATE INDEX</a>。</p>
  <p _msttexthash="747077084" _msthash="388">此 pragma 执行的优化的详细信息是预期的
 随着时间的推移而改变和改进。应用程序应预见到
 此 pragma 将在将来的版本中执行新的优化。</p>

  <p _msttexthash="122587257" _msthash="389">可选的 MASK 参数是要执行的优化的位掩码：</p><table border="0" cellspacing="14" cellpadding="0">
  <tbody><tr><td valign="top" _msttexthash="51337" _msthash="390">0x00001</td><td _msttexthash="360967828" _msthash="391">调试模式。实际上不执行任何优化
 而是为每个优化返回一行文本
 那本来可以做到的。默认为 Off。</td></tr><tr><td valign="top" _msttexthash="51506" _msthash="392">0x00002</td><td _msttexthash="79088893" _msthash="393">对可能受益的表运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_analyze.html" _istranslated="1">ANALYZE</a>。默认为 ON。</td></tr><tr><td valign="top" _msttexthash="51324" _msthash="394">0x00010</td><td _msttexthash="349600316" _msthash="395">运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_analyze.html" _istranslated="1">ANALYZE</a> 时，将临时 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_analysis_limit" _istranslated="1">PRAGMA analysis_limit</a>设置为
 防止运行时间过长。默认为 ON。</td></tr><tr><td valign="top" _msttexthash="51285" _msthash="396">0x10000</td><td _msttexthash="710376576" _msthash="397">检查所有表的大小，而不仅仅是尚未检查的表
 最近使用，以查看是否有任何明显增长和收缩
 因此可能会
 从重新分析中受益。默认为 Off。</td></tr></tbody></table>
  <p _msttexthash="14163747" _msthash="398">默认 MASK 为 0xfffe。</p>

  <p _msttexthash="357449092" _msthash="399">要查看本来可以完成的所有优化，而实际上
 执行这些作时，请运行 “PRAGMA optimize（-1）”。</p>
  
  <p><b _msttexthash="21874203" _msthash="400">确定何时运行 Analyze</b></p>
  <p _msttexthash="140505001" _msthash="401">在当前实现中，当且仅当
 以下所有情况均为正确：</p><ol>
  <li _msttexthash="26560157" _msthash="402">MASK 位 0x02 已设置。</li><li _msttexthash="141725129" _msthash="403">该表是一个普通的表，而不是一个视图或虚拟表。</li><li _msttexthash="29803137" _msthash="404">表名不以 “sqlite_” 开头。</li><li><font _mstmutation="1" _msttexthash="61520589" _msthash="405">满足以下一项或多项条件：</font><ol type="a">
    <li _msttexthash="17447287" _msthash="406">设置 MASK 的 0x10000 位</li><li _msttexthash="118939210" _msthash="407">表上的一个或多个索引在 sqlite_stat1 表中缺少条目。</li><li _msttexthash="474976814" _msthash="408">查询计划程序对一个或多个索引使用sqlite_stat1统计信息
 在当前数据库的生命周期内的某个时间点
 连接。</li></ol>
  </li><li><font _mstmutation="1" _msttexthash="61520589" _msthash="409">满足以下一项或多项条件：</font><ol type="a">
    <li _msttexthash="118939210" _msthash="410">表上的一个或多个索引在 sqlite_stat1 表中缺少条目。</li><li _msttexthash="150212023" _msthash="411">表中的行数增加了或减少了 10 倍
 自上次对表运行 ANALYZE 以来。</li></ol>
  </li></ol>
  <p><font _mstmutation="1" _msttexthash="1039011688" _msthash="412">分析表的规则可能会发生变化
 未来版本。将来可能会添加新的 MASK 值。前途
 此 pragma 的版本可能会接受 String Literal 参数
 的 bit mask 中，但将继续支持 bit mask 参数
 以实现向后兼容性。</font><a name="pragma_page_count"></a>
<h _id="pragma_page_count" style="display:none" _msttexthash="296673" _msthidden="1" _msthash="413"> PRAGMA page_count</h></p><hr>
    <p _msttexthash="12064494" _msthash="414"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">page_count;</b></p>
    <p _msttexthash="55363880" _msthash="415">返回数据库文件中的总页数。</p>
<a name="pragma_page_size"></a>
<h _id="pragma_page_size" style="display:none" _msttexthash="264602" _msthidden="1" _msthash="416"> PRAGMA page_size</h><hr>
   <p><font _mstmutation="1" _msttexthash="74211241" _msthash="417"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">page_size;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">page_size = </b><i _mstmutation="1" _istranslated="1">字节</i></font><b>;</b></p>
    <p _msttexthash="331285604" _msthash="418">查询或设置数据库的页面大小。页面
 size 必须是 512 和 65536 之间的 2 的幂（含 512 和 65536）。</p>

    <p _msttexthash="2321828613" _msthash="419">创建新数据库时，SQLite 会为
 基于 Platform 和 Filesystem 的数据库。多年来，
 默认页面大小几乎总是 1024 字节，但从
 使用 SQLite <a href="https://www.sqlite.org/releaselog/3_12_0.html" _istranslated="1">版本 3.12.0</a> （2016-03-29），
 默认页面大小增加到 4096。
 对于大多数应用程序，建议使用默认页面大小。</p><p _msttexthash="2032685356" _msthash="420">指定新的页面大小不会更改页面大小
 马上。相反，系统会记住并使用新的页面大小
 在首次创建数据库时设置页面大小（如果这样做）
 在发出 page_size pragma 时不存在，或者在
 next <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 命令，该命令在同一数据库连接上运行
 while 不在 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 模式下</a>。</p>

    <p><font _mstmutation="1" _msttexthash="438822670" _msthash="421">可以使用 <a href="https://www.sqlite.org/compile.html#default_page_size" _mstmutation="1" _istranslated="1">SQLITE_DEFAULT_PAGE_SIZE</a> compile-time 选项
 以更改分配给新数据库的默认页面大小。</font><a name="pragma_parser_trace"></a>
<h _id="pragma_parser_trace" style="display:none" _msttexthash="359125" _msthidden="1" _msthash="422"> PRAGMA parser_trace</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="24263928" _msthash="423"><b _mstmutation="1" _istranslated="1">PRAGMA parser_trace = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>; </b></p>

    <p _msttexthash="976285765" _msthash="424">如果 SQLite 已使用 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> 编译时进行编译
 选项，则 parser_trace pragma 可用于启用跟踪
 对于 SQLite 内部使用的 SQL 解析器。
 此功能用于调试 SQLite 本身。</p>

    
    <p style="background-color: #f0e0ff;" _msttexthash="223800174" _msthash="425">此 pragma 旨在用于调试 SQLite 本身。它
 仅在 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> compile-time 选项
 被使用。</p>
  
<a name="pragma_pragma_list"></a>
<h _id="pragma_pragma_list" style="display:none" _msttexthash="328380" _msthidden="1" _msthash="426"> PRAGMA pragma_list</h><hr>
    <p><b _msttexthash="346788" _msthash="427">PRAGMA pragma_list;</b>
    </p><p><font _mstmutation="1" _msttexthash="121951206" _msthash="428">此 pragma 返回 PRAGMA 命令列表
 数据库连接已知。</font><a name="pragma_query_only"></a>
<h _id="pragma_query_only" style="display:none" _msttexthash="306670" _msthidden="1" _msthash="429"> PRAGMA query_only</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="38185355" _msthash="430"><b _mstmutation="1" _istranslated="1">PRAGMA query_only;<br _istranslated="1">PRAGMA query_only = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="2759252431" _msthash="431">在以下情况下，query_only pragma 会阻止数据库文件上的数据更改
 启用。启用此 pragma 后，对 CREATE、DELETE 和
 DROP、INSERT 或 UPDATE 将导致 <a href="https://www.sqlite.org/rescode.html#readonly" _istranslated="1">SQLITE_READONLY</a> 错误。
 但是，数据库并不是真正的只读数据库。您仍然可以运行
 <a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">checkpoint</a> 或 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_transaction.html" _istranslated="1">COMMIT</a> 和 <a href="https://www.sqlite.org/c3ref/db_readonly.html" _istranslated="1">sqlite3_db_readonly（）</a> 例程的返回值不受影响。</p>
<a name="pragma_quick_check"></a>
<h _id="pragma_quick_check" style="display:none" _msttexthash="320502" _msthidden="1" _msthash="432"> PRAGMA quick_check</h><hr>
    <p><font _mstmutation="1" _msttexthash="305666556" _msthash="433"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">quick_check;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">quick_check（</b><i _mstmutation="1" _istranslated="1">N</i><b _mstmutation="1" _istranslated="1">）</b> <br _mstmutation="1" _istranslated="1">PRAGMA <i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">quick_check（</b><i _mstmutation="1" _istranslated="1">TABLENAME）</i></font><b>)</b></p>
    <p _msttexthash="3512245698" _msthash="434">该 pragma 与 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_integrity_check" _istranslated="1">integrity_check</a> 类似，只是它不验证
 UNIQUE 约束，并且不验证
 索引内容与表内容匹配。通过跳过 UNIQUE
 和索引一致性检查，quick_check能够运行得更快。
 PRAGMA quick_check 在 O（N） 时间内运行，而 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_integrity_check" _istranslated="1">PRAGMA integrity_check</a> 需要 O（NlogN） 时间，其中 N 是
 数据库。否则，两个 pragma 是相同的。</p>
<a name="pragma_read_uncommitted"></a>
<h _id="pragma_read_uncommitted" style="display:none" _msttexthash="508027" _msthidden="1" _msthash="435"> PRAGMA read_uncommitted</h><hr>
    <p><font _mstmutation="1" _msttexthash="49535200" _msthash="436"><b _mstmutation="1" _istranslated="1">PRAGMA read_uncommitted;<br _istranslated="1">PRAGMA read_uncommitted = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="3187646384" _msthash="437">查询、设置或清除 READ UNCOMMITTED 隔离。默认隔离
 级别是 SERIALIZABLE。任何进程或线程都可以选择
 READ UNCOMMITTED 隔离，但仍将使用 SERIALIZABLE，但
 在共享公共页面和 Schema 缓存的连接之间。
 使用 <a href="https://www.sqlite.org/c3ref/enable_shared_cache.html" _istranslated="1">sqlite3_enable_shared_cache（）</a> API 启用缓存共享。
 默认情况下，缓存共享处于禁用状态。</p>

    <p _msttexthash="101283260" _msthash="438">有关更多信息，请参阅 <a href="https://www.sqlite.org/sharedcache.html" _istranslated="1">SQLite 共享缓存模式</a>。</p>
<a name="pragma_recursive_triggers"></a>
<h _id="pragma_recursive_triggers" style="display:none" _msttexthash="598481" _msthidden="1" _msthash="439"> PRAGMA recursive_triggers</h><hr>
    <p><font _mstmutation="1" _msttexthash="53403012" _msthash="440"><b _mstmutation="1" _istranslated="1">PRAGMA recursive_triggers;<br _istranslated="1">PRAGMA recursive_triggers = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="81164850" _msthash="441">查询、设置或清除递归触发器功能。</p><p _msttexthash="1751167951" _msthash="442">更改 recursive_triggers 设置会影响
 所有报表均已准备就绪
 使用数据库连接，包括在
 设置已更改。使用旧版 <a href="https://www.sqlite.org/c3ref/prepare.html" _istranslated="1">sqlite3_prepare（）</a> 接口准备的任何现有语句都可能失败，并显示 <a href="https://www.sqlite.org/rescode.html#schema" _istranslated="1">SQLITE_SCHEMA</a> 错误
 更改 recursive_triggers 设置后。</p><p _msttexthash="2601229176" _msthash="443">在 SQLite <a href="https://www.sqlite.org/releaselog/3_6_18.html" _istranslated="1">版本 3.6.18</a> （2009-09-11） 之前，
 不支持递归触发器。
 SQLite 的行为总是好像这个 pragma 是
 设置为 OFF。版本 3.6.18 中添加了对递归触发器的支持
 但为了兼容性，最初默认处于 OFF 状态。递归的
 在 SQLite 的未来版本中，触发器可能会默认打开。</p>

    <p _msttexthash="667859816" _msthash="444">触发器的递归深度有一个硬性上限，由
 <a href="https://www.sqlite.org/limits.html#max_trigger_depth" _istranslated="1">SQLITE_MAX_TRIGGER_DEPTH</a> 编译时选项和运行时
 limit 由 <a href="https://www.sqlite.org/c3ref/limit.html" _istranslated="1">sqlite3_limit</a>（<a href="https://www.sqlite.org/c3ref/c_limit_attached.html#sqlitelimittriggerdepth" _istranslated="1">db，SQLITE_LIMIT_TRIGGER_DEPTH</a>,...） 设置。</p>
<a name="pragma_reverse_unordered_selects"></a>
<h _id="pragma_reverse_unordered_selects" style="display:none" _msttexthash="921518" _msthidden="1" _msthash="445"> PRAGMA reverse_unordered_selects</h><hr>
    <p><font _mstmutation="1" _msttexthash="66994057" _msthash="446"><b _mstmutation="1" _istranslated="1">PRAGMA reverse_unordered_selects;<br _istranslated="1">PRAGMA reverse_unordered_selects = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="5185914786" _msthash="447">启用后，此 PRAGMA 会导致许多 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_select.html" _istranslated="1">SELECT</a> 语句，而没有
 一个 ORDER BY 子句，以与 what 相反的顺序发出它们的结果
 他们通常会这样做。这有助于调试
 对结果顺序做出无效的假设。
 reverse_unordered_selects pragma 适用于大多数 SELECT 语句，
 但是，查询计划程序有时可能会选择一种算法，即
 不容易反转，在这种情况下，输出将以相同的方式显示
 order 而不管 reverse_unordered_selects 设置如何。</p><p _msttexthash="10566814258" _msthash="448">SQLite 不会
 保证如果 SELECT 省略 ORDER BY 则结果的顺序
 第。即便如此，结果的顺序也不会从 1 开始改变
 运行到下一个，因此许多应用程序错误地开始依赖
 在任意输出顺序上，无论该顺序是什么。然而
 有时 SQLite 的新版本将包含优化器增强功能
 这将导致没有 ORDER BY 子句的查询的输出顺序
 进行移位。发生这种情况时，依赖于某个
 Output Order 可能会出错。通过运行应用程序多个
 同时禁用和启用此 pragma 的时间，其中
 应用程序对输出顺序做出错误的假设可以是
 及早发现并修复，减少问题
 这可能是由于链接到不同版本的 SQLite 引起的。</p>
<a name="pragma_schema_version"></a>
<h _id="pragma_schema_version" style="display:none" _msttexthash="434044" _msthidden="1" _msthash="449"> PRAGMA schema_version</h><hr>
    <p><font _mstmutation="1" _msttexthash="82927624" _msthash="450"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">schema_version;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">schema_version = </b><i _mstmutation="1" _istranslated="1">整数 </i></font>;

</p><p _msttexthash="338173420" _msthash="451">schema_version 编译指示将获取或设置
 <a href="https://www.sqlite.org/fileformat2.html#database_header" _istranslated="1">数据库标头</a>中偏移量为 40 处的 schema-version 整数的值。</p><p _msttexthash="4749814277" _msthash="452">每当
 架构更改。当每个 SQL 语句运行时，架构版本为
 检查以确保架构自 SQL
 <a href="https://www.sqlite.org/c3ref/prepare.html" _istranslated="1">声明</a>。
 通过使用 “PRAGMA schema_version=N” 来颠覆此机制
 更改 schema_version
 可能会导致 SQL 语句使用过时的架构运行，
 这可能会导致答案错误和/或<a href="https://www.sqlite.org/howtocorrupt.html#cfgerr" _istranslated="1">数据库损坏</a>。
 读取 schema_version 始终是安全的，但更改
 schema_version 可能会导致问题。因此，尝试
 更改 schema_version are a silent no-op 的值<a href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive" _istranslated="1">，当为</a>
 数据库连接。</p><p><span style="background-color: #ffff60;" _msttexthash="108852666" _msthash="453"><b _istranslated="1">警告：</b>误用此 pragma 可能会导致<a href="https://www.sqlite.org/howtocorrupt.html#cfgerr" _istranslated="1">数据库损坏</a>。</span></p>
  

<p _msttexthash="394733209" _msthash="454">对于此 pragma，将 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 命令视为
 架构更改，因为 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a> 通常会更改 “rootpage”
 <a href="https://www.sqlite.org/schematab.html" _istranslated="1">sqlite_schema表中</a>条目的值。</p><p><font _mstmutation="1" _msttexthash="31475665" _msthash="455">另请参阅 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_application_id" _mstmutation="1" _istranslated="1">application_id pragma</a> 和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_user_version" _mstmutation="1" _istranslated="1">user_version pragma</a>。</font><a name="pragma_secure_delete"></a>
<h _id="pragma_secure_delete" style="display:none" _msttexthash="391222" _msthidden="1" _msthash="456"> PRAGMA secure_delete</h></p><hr>
    <p _msttexthash="110544590" _msthash="457"><b _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">secure_delete;<br _istranslated="1">PRAGMA </b><i _istranslated="1">架构。</i><b _istranslated="1">secure_delete = </b><i _istranslated="1">布尔值</i>|<b _istranslated="1">快</b></p>
    <p _msttexthash="5412366999" _msthash="458">查询或更改 secure-delete 设置。当 secure_delete 为
 上，SQLite 会用零覆盖已删除的内容。默认的
 secure_delete 的设置由 <a href="https://www.sqlite.org/compile.html#secure_delete" _istranslated="1">SQLITE_SECURE_DELETE</a> 编译时选项确定，通常为 off。的 off 设置
 secure_delete 通过减少 CPU 周期数来提高性能
 以及磁盘 I/O 的数量。希望避免离开
 删除或更新内容后的取证跟踪应启用
 secure_delete pragma 执行删除或更新之前，否则
 在删除或更新后运行 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_vacuum.html" _istranslated="1">VACUUM</a>。</p><p _msttexthash="4979838175" _msthash="459">secure_delete的“快速”设置（大约在 2017 年 8 月 1 日添加）
 是介于 “on” 和 “off” 之间的中间设置。
 当 secure_delete 设置为 “fast” 时，
 仅当这样做时，SQLite 才会用零覆盖已删除的内容
 不会增加 I/O 量。换句话说，“快速”
 设置会使用更多的 CPU 周期，但不使用更多的 I/O。
 这具有从 <a href="https://www.sqlite.org/fileformat2.html#btree" _istranslated="1">b 树页面</a>清除所有旧内容的效果，
 但在 <a href="https://www.sqlite.org/fileformat2.html#freelist" _istranslated="1">freelist 页面上</a>留下法医痕迹。</p><p _msttexthash="1053046592" _msthash="460">当有<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_attach.html" _istranslated="1">附加的数据库</a>但没有数据库时
 在 pragma 中指定，则所有数据库都有其 secure-delete
 设置已更改。
 新附加数据库的 secure-delete 设置是
 在评估 ATTACH 命令时，主数据库的 ADD。</p><p _msttexthash="331002035" _msthash="461">当多个数据库连接共享同一缓存时，将
 一个数据库连接上的 secure-delete 标志会为他们更改
 都。</p>

    <p _msttexthash="2916228315" _msthash="462"><b _istranslated="1">限度：</b>secure_delete pragma 仅导致已删除的内容被清理
 从普通表中。如果<a href="https://www.sqlite.org/vtab.html" _istranslated="1">虚拟表</a>将内容存储在<a href="https://www.sqlite.org/vtab.html#xshadowname" _istranslated="1">影子表中</a>，则从虚拟表中删除内容会
 不必从影子表中删除取证跟踪。
 特别是，即将到来的<a href="https://www.sqlite.org/fts3.html" _istranslated="1">FTS3</a>和<a href="https://www.sqlite.org/fts5.html" _istranslated="1">FTS5</a>虚拟表
 与 SQLite 捆绑在一起可能会在其影子表中留下取证痕迹
 即使启用了 secure_delete 杂注。</p>
<a name="pragma_short_column_names"></a>
<h _id="pragma_short_column_names" style="display:none" _msttexthash="593255" _msthidden="1" _msthash="463"> PRAGMA short_column_names</h><hr>
    <p><font _mstmutation="1" _msttexthash="53388010" _msthash="464"><b _mstmutation="1" _istranslated="1">PRAGMA short_column_names;<br _istranslated="1">PRAGMA short_column_names = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="731579745" _msthash="465">查询或更改 short-column-names 标志。此标志会影响
 SQLite 命名 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_select.html" _istranslated="1">SELECT</a> 语句返回的数据列的方式。
 有关完整详细信息，请参阅 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_full_column_names" _istranslated="1">full_column_names</a> pragma。</p>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="466"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_shrink_memory"></a>
<h _id="pragma_shrink_memory" style="display:none" _msttexthash="404209" _msthidden="1" _msthash="467"> PRAGMA shrink_memory</h><hr>
    <p><b _msttexthash="404209" _msthash="468">PRAGMA shrink_memory</b></p>

    <p _msttexthash="666753958" _msthash="469">此 pragma 会导致调用它的数据库连接
 以释放尽可能多的内存，通过调用 <a href="https://www.sqlite.org/c3ref/db_release_memory.html" _istranslated="1">sqlite3_db_release_memory（）</a> 来释放尽可能多的内存。</p>
<a name="pragma_soft_heap_limit"></a>
<h _id="pragma_soft_heap_limit" style="display:none" _msttexthash="467376" _msthidden="1" _msthash="470"> PRAGMA soft_heap_limit</h><hr>
    <p _msttexthash="1578772" _msthash="471"><b>PRAGMA soft_heap_limit<br>
          PRAGMA soft_heap_limit=</b><i>N</i></p>

    <p _msttexthash="1209022815" _msthash="472">此编译指示<a href="https://www.sqlite.org/c3ref/hard_heap_limit64.html" _istranslated="1">sqlite3_soft_heap_limit64</a>使用
 参数 N（如果指定了 N 并且是非负整数）。
 soft_heap_limit pragma 始终返回相同的整数
 将由 <a href="https://www.sqlite.org/c3ref/hard_heap_limit64.html" _istranslated="1">sqlite3_soft_heap_limit64</a>（-1） C 语言返回
 功能。</p>
    <p><font _mstmutation="1" _msttexthash="18896111" _msthash="473">另请参阅 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_hard_heap_limit" _mstmutation="1" _istranslated="1">hard_heap_limit pragma</a>。</font><a name="pragma_stats"></a>
<h _id="pragma_stats" style="display:none" _msttexthash="162799" _msthidden="1" _msthash="474"> PRAGMA stats</h></p><hr>
    <p><b _msttexthash="12059840" _msthash="475">PRAGMA 统计;</b> </p>
    <p _msttexthash="1750098610" _msthash="476">此 pragma 返回有关 tables 和
 指标。返回的信息在测试期间用于帮助
 验证 Query Planner 是否正常运行。格式
 此 pragma 的含义可能会从一个版本开始更改
 到下一个。由于其波动性，行为和输出
 格式是故意未记录的。</p>

    
    <p style="background-color: #f0e0ff;" _msttexthash="637085098" _msthash="477">此 pragma 的预期用途仅用于测试和验证
 SQLite 的此 pragma 如有更改，恕不另行通知，并且不会
 建议供应用程序使用。</p>
  
<a name="pragma_synchronous"></a>
<h _id="pragma_synchronous" style="display:none" _msttexthash="341120" _msthidden="1" _msthash="478"> PRAGMA synchronous</h><hr>
    <p><font _mstmutation="1" _msttexthash="205467977" _msthash="479"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">同步;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">同步 = </b> <i _mstmutation="1" _istranslated="1">0 |关闭 |1 |普通 |2 |完整版 |3 |额外</i></font><b>;</b></p>

    <p _msttexthash="955940505" _msthash="480">查询或更改 “synchronous” 标志的设置。
 第一个（查询）表单将返回同步设置作为
 整数。第二种形式更改同步设置。
 各种同步设置的含义如下：</p>
    <dl>
    <dt _msttexthash="22908756" _msthash="481"><b _istranslated="1">额外</b> （3）</dt>
    <dd _msttexthash="1055503917" _msthash="482">EXTRA synchronous 与 FULL 类似，但目录
 包含<a href="https://www.sqlite.org/lockingv3.html#rollback" _istranslated="1">回滚日志</a>的日志将在该日志取消链接后同步
 以 DELETE 模式提交事务。EXTRA 提供额外的
 durability （如果提交紧随 power loss）。</dd>
    <dt _msttexthash="17179812" _msthash="483"><b _istranslated="1">全</b> （2）</dt>
    <dd _msttexthash="2316921217" _msthash="484">当 synchronous 为 FULL （2） 时，SQLite 数据库引擎将
 使用 <a href="https://www.sqlite.org/vfs.html" _istranslated="1">VFS</a> 的 xSync 方法确保所有内容都安全
 在继续之前写入磁盘表面。
 这可确保作系统崩溃或电源故障
 不会损坏数据库。
 FULL synchronous 非常安全，但也比较慢。FULL 是
 不处于 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 模式</a>时最常用的 synchronous setting。</dd>
    <dt _msttexthash="23204155" _msthash="485"><b _istranslated="1">普通</b> （1）</dt>
    <dd _msttexthash="13845759564" _msthash="486">当 synchronous 为 NORMAL （1） 时，SQLite 数据库
 引擎仍将在最关键的时刻同步，但频率较低
 比在 FULL 模式下。有非常小（尽管非零）的可能性
 在错误的时间发生的电源故障可能会损坏较旧文件系统上 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_mode" _istranslated="1">journal_mode</a>=DELETE 中的数据库。<a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 模式</a>在 synchronous=NORMAL 下不会损坏，并且可能
 DELETE 模式在现代文件系统上也是安全的。WAL 模式始终一致
 与 synchronous=NORMAL 一起使用，但 WAL 模式确实会失去持久性。交易
 在 WAL 模式下使用 synchronous=NORMAL 提交可能会回滚
 断电或系统崩溃。事务跨应用程序是持久的
 无论 synchronous setting 或 journal 模式如何，都会崩溃。
 synchronous=NORMAL 设置对于大多数应用程序来说都是一个不错的选择
 在 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 模式下</a>运行。</dd>
    <dt _msttexthash="17180579" _msthash="487"><b _istranslated="1">关</b> （0）</dt>
    <dd _msttexthash="2209610832" _msthash="488">使用同步 OFF （0） 时，SQLite 继续而不同步
 一旦它将数据移交给作系统。
 如果运行 SQLite 的应用程序崩溃，数据将是安全的，但
 <a href="https://www.sqlite.org/howtocorrupt.html#cfgerr" _istranslated="1">如果作系统</a>
 崩溃或计算机在写入该数据之前断电
 到磁盘表面。另一方面，提交可以是
 同步 OFF 时幅度更快。</dd></dl>
    <p></p>
 
    <p _msttexthash="7940038418" _msthash="489">在 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL</a> 模式下，当 synchronous 为 NORMAL （1） 时，WAL 文件为
 在每个 <a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">checkpoint</a> 之前同步，数据库文件为
 在每个完成的 <a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">checkpoint</a> 和 WAL 文件后同步
 当 WAL 文件在
 检查点，但在大多数事务期间不会发生同步作。
 在 WAL 模式下使用 synchronous=FULL 时，会有一个额外的
 sync作 WAL 文件在每次事务提交后进行。
 每个事务之后的额外 WAL 同步有助于确保
 事务在断电期间是持久的。交易包括
 无论是否提供 额外同步
 synchronous=FULL 的
 如果不考虑持久性，则 synchronous=NORMAL 通常为
 在 WAL 模式下只需要。</p>

    <p _msttexthash="912283632" _msthash="490">TEMP 架构始终具有 synchronous=OFF，因为
 的 TEMP 是短暂的，预计不会在停电后幸存下来。
 尝试更改 TEMP 的同步设置的尝试包括
 默默地忽略。</p><p _msttexthash="27541332" _msthash="491">另请参见 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_fullfsync" _istranslated="1">fullfsync</a> 和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_checkpoint_fullfsync" _istranslated="1">checkpoint_fullfsync</a> pragmas。</p>
<a name="pragma_table_info"></a>
<h _id="pragma_table_info" style="display:none" _msttexthash="291304" _msthidden="1" _msthash="492"> PRAGMA table_info</h><hr>
    <p><font _mstmutation="1" _msttexthash="54194933" _msthash="493"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">table_info（</b><i _mstmutation="1" _istranslated="1">表名</i></font><b>);</b></p>
    <p _msttexthash="3171207130" _msthash="494">此 pragma 为每个普通列返回一行
 在命名表中。
 结果集中的列包括： “name” （其名称）;“类型”
 （数据类型如果给定，则为 ''）;“notnull” （无论列是否
 可以是 NULL）;“dflt_value” （列的默认值）;
 和 “pk”（对于不属于主键的列，则为零，
 或主键中列的从 1 开始的索引）。</p>
    <p _msttexthash="135051488" _msthash="495">“cid” 列不应被视为超过
 “在当前结果集中排名”。</p>
    <p _msttexthash="75492001" _msthash="496">table_info pragma 中命名的 table 也可以是 view。</p>
    <p><font _mstmutation="1" _msttexthash="501504757" _msthash="497">此 pragma 不显示有关<a href="https://www.sqlite.org/gencol.html" _mstmutation="1" _istranslated="1">生成列</a>或<a href="https://www.sqlite.org/vtab.html#hiddencol" _mstmutation="1" _istranslated="1">隐藏列</a>的信息。使用 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_table_xinfo" _mstmutation="1" _istranslated="1">PRAGMA table_xinfo</a> 获取更完整的列表
 of 列，其中包括 generated 列和 hidden 列。</font><a name="pragma_table_list"></a>
<h _id="pragma_table_list" style="display:none" _msttexthash="295724" _msthidden="1" _msthash="498"> PRAGMA table_list</h></p><hr>
    <p> <font _mstmutation="1" _msttexthash="177608626" _msthash="499"><b _mstmutation="1" _istranslated="1">PRAGMA table_list;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">table_list;<br _istranslated="1">PRAGMA table_list（</b><i _mstmutation="1" _istranslated="1">表名</i>）</font><b>);</b></p>
    <p _msttexthash="1803126507" _msthash="500">此 pragma 返回有关架构中的表和视图的信息。
 每行输出一个表。table_list pragma 首次出现
 在 SQLite 版本 3.37.0 （2021-11-27） 中。截至其初始版本
 table_list pragma 返回的列包括下面列出的列。
 SQLite 的未来版本可能会添加
 输出。</p><p>
    </p><ol>
    <li> <font _mstmutation="1" _msttexthash="193836461" _msthash="501"><b _mstmutation="1" _istranslated="1">Schema</b>：显示表或视图的 Schema
 （例如，“main” 或 “temp”）。</font></li><li> <font _mstmutation="1" _msttexthash="51243790" _msthash="502"><b _mstmutation="1" _istranslated="1">name</b>：表或视图的名称。</font></li><li> <font _mstmutation="1" _msttexthash="408493774" _msthash="503"><b _mstmutation="1" _istranslated="1">type</b>： 对象的类型 - “table”、“view”、
 “shadow” （用于<a href="https://www.sqlite.org/vtab.html#xshadowname" _mstmutation="1" _istranslated="1">影子表</a>），或 “virtual” 用于<a href="https://www.sqlite.org/vtab.html" _mstmutation="1" _istranslated="1">虚拟表</a>。</font></li><li> <font _mstmutation="1" _msttexthash="120601000" _msthash="504"><b _mstmutation="1" _istranslated="1">ncol</b>：表中的列数，包括<a href="https://www.sqlite.org/gencol.html" _mstmutation="1" _istranslated="1">生成列</a>和<a href="https://www.sqlite.org/vtab.html#hiddencol" _mstmutation="1" _istranslated="1">隐藏列</a>。</font></li><li> <font _mstmutation="1" _msttexthash="173126382" _msthash="505"><b _mstmutation="1" _istranslated="1">wr</b>：如果表是 <a href="https://www.sqlite.org/withoutrowid.html" _mstmutation="1" _istranslated="1">WITHOUT ROWID</a> 表，则为 1;如果不是，则为 0。</font></li><li> <font _mstmutation="1" _msttexthash="172967353" _msthash="506"><b _mstmutation="1" _istranslated="1">strict</b>：如果表是 <a href="https://www.sqlite.org/stricttables.html" _mstmutation="1" _istranslated="1">STRICT 表</a>，则为 1;如果不是，则为 0。</font></li><li> <i _msttexthash="55099746" _msthash="507">未来版本中可能会添加其他列。</i>
    </li></ol>
    <p><font _mstmutation="1" _msttexthash="905751860" _msthash="508">默认行为是显示所有架构中的所有表。如果 <i _mstmutation="1" _istranslated="1">schema.</i> name 出现在 pragma 之前，则只有该
 显示了一个 schema。如果提供了 <i _mstmutation="1" _istranslated="1">table-name</i> 参数，则
 仅返回有关该 table 的信息。</font><a name="pragma_table_xinfo"></a>
<h _id="pragma_table_xinfo" style="display:none" _msttexthash="326508" _msthidden="1" _msthash="509"> PRAGMA table_xinfo</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="81279952" _msthash="510"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">table_xinfo（</b><i _mstmutation="1" _istranslated="1">表名）</i></font><b>);</b></p>
    <p><font _mstmutation="1" _msttexthash="2687914788" _msthash="511">此 pragma 为命名表中的每一列返回一行，
 包括<a href="https://www.sqlite.org/gencol.html" _mstmutation="1" _istranslated="1">生成列</a>和<a href="https://www.sqlite.org/vtab.html#hiddencol" _mstmutation="1" _istranslated="1">隐藏列</a>。
 输出的列与 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_table_info" _mstmutation="1" _istranslated="1">PRAGMA table_info</a> plus 的列相同
 列 “hidden”，其值表示普通列 （0），
 动态或存储的生成列（2 或 3），
 或虚拟表中的隐藏列 （1）。其中
 此字段为非零是 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_table_info" _mstmutation="1" _istranslated="1">PRAGMA table_info</a> 省略的字段。</font><a name="pragma_temp_store"></a>
<h _id="pragma_temp_store" style="display:none" _msttexthash="301756" _msthidden="1" _msthash="512"> PRAGMA temp_store</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="115583481" _msthash="513"><b _mstmutation="1" _istranslated="1">PRAGMA temp_store;<br _istranslated="1">PRAGMA temp_store = </b> <i _mstmutation="1" _istranslated="1">0 |默认 |1 |文件 |2 |记忆</i></font><b>;</b></p>

    <p _msttexthash="7601353942" _msthash="514">查询或更改 <b _istranslated="1">temp_store</b> 参数的设置。
 当 temp_store 为 DEFAULT （0） 时，编译时 C 预处理器宏<a href="https://www.sqlite.org/compile.html#temp_store" _istranslated="1">SQLITE_TEMP_STORE</a>用于确定临时表和索引的位置
 被存储。什么时候
 temp_store 是 MEMORY （2），则保留<a href="https://www.sqlite.org/inmemorydb.html#temp_db" _istranslated="1">临时表</a>和索引
 就像它们在纯<a href="https://www.sqlite.org/inmemorydb.html" _istranslated="1">内存数据库中</a>一样。
 当 temp_store 为 FILE （1） 时，将存储<a href="https://www.sqlite.org/inmemorydb.html#temp_db" _istranslated="1">临时表</a>和索引
 在文件中。<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_temp_store_directory" _istranslated="1">temp_store_directory</a> pragma 可用于指定
 指定 <b _istranslated="1">FILE</b> 时包含临时文件的目录。更改 temp_store 设置时，
 所有现有的临时表、索引、触发器和视图都是
 立即删除。</p>

    <p _msttexthash="478007270" _msthash="515">库编译时 C 预处理器符号 <a href="https://www.sqlite.org/compile.html#temp_store" _istranslated="1">SQLITE_TEMP_STORE</a> 可以覆盖此 pragma 设置。
 下表总结了
 <a href="https://www.sqlite.org/compile.html#temp_store" _istranslated="1">SQLITE_TEMP_STORE</a> 预处理器宏与
 temp_store pragma：</p>

    <blockquote>
    <table cellpadding="2" border="1">
    <tbody><tr><th valign="bottom"><a href="https://www.sqlite.org/compile.html#temp_store" _msttexthash="265850" _msthash="516">SQLITE_TEMP_STORE</a></th>
        <th valign="bottom" _msttexthash="301756" _msthash="517">PRAGMA<br>temp_store</th>
        <th _msttexthash="43290299" _msthash="518">用于<br _istranslated="1">TEMP 表和索引的存储</th></tr>
    <tr><td align="center" _msttexthash="4368" _msthash="519">0</td>
        <td align="center"><em _msttexthash="3952065" _msthash="520">任何</em></td>
        <td align="center" _msttexthash="4467437" _msthash="521">文件</td></tr>
    <tr><td align="center" _msttexthash="4459" _msthash="522">1</td>
        <td align="center" _msttexthash="4368" _msthash="523">0</td>
        <td align="center" _msttexthash="4467437" _msthash="524">文件</td></tr>
    <tr><td align="center" _msttexthash="4459" _msthash="525">1</td>
        <td align="center" _msttexthash="4459" _msthash="526">1</td>
        <td align="center" _msttexthash="4467437" _msthash="527">文件</td></tr>
    <tr><td align="center" _msttexthash="4459" _msthash="528">1</td>
        <td align="center" _msttexthash="4550" _msthash="529">2</td>
        <td align="center" _msttexthash="5804032" _msthash="530">记忆</td></tr>
    <tr><td align="center" _msttexthash="4550" _msthash="531">2</td>
        <td align="center" _msttexthash="4368" _msthash="532">0</td>
        <td align="center" _msttexthash="5804032" _msthash="533">记忆</td></tr>
    <tr><td align="center" _msttexthash="4550" _msthash="534">2</td>
        <td align="center" _msttexthash="4459" _msthash="535">1</td>
        <td align="center" _msttexthash="4467437" _msthash="536">文件</td></tr>
    <tr><td align="center" _msttexthash="4550" _msthash="537">2</td>
        <td align="center" _msttexthash="4550" _msthash="538">2</td>
        <td align="center" _msttexthash="5804032" _msthash="539">记忆</td></tr>
    <tr><td align="center" _msttexthash="4641" _msthash="540">3</td>
        <td align="center"><em _msttexthash="3952065" _msthash="541">任何</em></td>
        <td align="center" _msttexthash="5804032" _msthash="542">记忆</td></tr>
    </tbody></table>
    </blockquote>
<a name="pragma_temp_store_directory"></a>
<h _id="pragma_temp_store_directory" style="display:none" _msttexthash="688805" _msthidden="1" _msthash="543"> PRAGMA temp_store_directory</h><hr>
    <p><font _mstmutation="1" _msttexthash="91202969" _msthash="544"><b _mstmutation="1" _istranslated="1">PRAGMA temp_store_directory;<br _istranslated="1">PRAGMA temp_store_directory = '</b><i _mstmutation="1" _istranslated="1">目录名称</i></font><b>';</b></p>
    <p _msttexthash="690215422" _msthash="545">查询或更改 <a href="https://www.sqlite.org/c3ref/temp_directory.html" _istranslated="1">sqlite3_temp_directory</a> 全局变量的值
 variable，许多作系统接口后端使用它来
 确定存储<a href="https://www.sqlite.org/inmemorydb.html#temp_db" _istranslated="1">临时表</a>和索引的位置。</p>

    <p _msttexthash="3374859982" _msthash="546">更改 temp_store_directory 设置时，所有现有的临时
 表、索引、触发器和查看器
 发出的 pragma 会立即删除。在
 practice 的 temp_store_directory 应在第一个
 打开进程的数据库连接。如果 temp_store_directory
 更改一个数据库连接，而其他数据库连接
 在同一进程中打开，则行为为 undefined 且
 可能是不可取的。</p>

    <p _msttexthash="2386245771" _msthash="547">更改 temp_store_directory 设置<u _istranslated="1">不是</u>线程安全的。
 如果另一个线程，则从不更改 temp_store_directory 设置
 同时运行任何 SQLite 接口。
 这样做会导致未定义的行为。更改 temp_store_directory
 设置写入 <a href="https://www.sqlite.org/c3ref/temp_directory.html" _istranslated="1">sqlite3_temp_directory</a> 全局
 变量，并且该全局变量不受互斥锁保护。</p>

    <p _msttexthash="1297645583" _msthash="548">值 <i _istranslated="1">directory-name</i> 应括在单引号中。
 要将目录恢复为默认值，请将 <i _istranslated="1">directory-name</i> 设置为
 空字符串，例如 <i _istranslated="1">PRAGMA temp_store_directory = ''</i>。一
 如果找不到 <i _istranslated="1">directory-name 或找不到 directory-name</i>，则会引发错误
 写。</p>

    <p _msttexthash="1027985296" _msthash="549">临时文件的默认目录取决于作系统。一些
 作系统接口可以选择忽略此变量并将
 文件位于与指定目录不同的其他目录中
 这里。从这个意义上说，这个 pragma 只是建议性的。</p>

    
    <p style="background-color: #ffd0d0;">
    <font _mstmutation="1" _msttexthash="1098072742" _msthash="550"><b _mstmutation="1" _istranslated="1">此 pragma 已弃用</b>并存在
 仅用于向后兼容。新应用
 应避免使用此 pragma。较旧的应用程序应停止使用
 尽早使用此 pragma。此 pragma 可以省略
 当使用 <a href="https://www.sqlite.org/compile.html#omit_deprecated" _mstmutation="1" _istranslated="1">SQLITE_OMIT_DEPRECATED</a> 编译 SQLite 时，从构建中。</font></p>
  
<a name="pragma_threads"></a>
<h _id="pragma_threads" style="display:none" _msttexthash="208806" _msthidden="1" _msthash="551"> PRAGMA threads</h><hr>
    <p><font _mstmutation="1" _msttexthash="30006223" _msthash="552"><b _mstmutation="1" _istranslated="1">PRAGMA 线程;<br _istranslated="1">PRAGMA 线程 = </b><i _mstmutation="1" _istranslated="1">N</i></font><b>;</b></p>
    <p _msttexthash="3381515982" _msthash="553">查询或更改 <a href="https://www.sqlite.org/c3ref/limit.html" _istranslated="1">sqlite3_limit</a>（<a href="https://www.sqlite.org/c3ref/c_limit_attached.html#sqlitelimitworkerthreads" _istranslated="1">db，SQLITE_LIMIT_WORKER_THREADS</a>,...） 限制的值
 当前数据库连接。此限制设置上限
 在<a href="https://www.sqlite.org/c3ref/stmt.html" _istranslated="1">准备好的语句</a>的辅助线程数上
 允许启动以协助查询。默认限制为 0
 除非使用 <a href="https://www.sqlite.org/compile.html#default_worker_threads" _istranslated="1">SQLITE_DEFAULT_WORKER_THREADS</a> compile-time 选项进行更改。当限制为零时，表示没有
 将启动辅助线程。</p>

    <p _msttexthash="316737460" _msthash="554">此 pragma 是 <a href="https://www.sqlite.org/c3ref/limit.html" _istranslated="1">sqlite3_limit</a>（<a href="https://www.sqlite.org/c3ref/c_limit_attached.html#sqlitelimitworkerthreads" _istranslated="1">db，SQLITE_LIMIT_WORKER_THREADS</a>,...） 接口的精简包装器。</p>
<a name="pragma_trusted_schema"></a>
<h _id="pragma_trusted_schema" style="display:none" _msttexthash="430079" _msthidden="1" _msthash="555"> PRAGMA trusted_schema</h><hr>
    <p><font _mstmutation="1" _msttexthash="45718777" _msthash="556"><b _mstmutation="1" _istranslated="1">PRAGMA trusted_schema;<br _istranslated="1">PRAGMA trusted_schema = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>
    <p _msttexthash="2952227356" _msthash="557">trusted_schema 设置是每个连接的布尔值，其中
 确定 SQL 函数和虚拟表是否
 未经过安全审计的允许由 views 运行，
 触发器，或在架构的表达式中，例如 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#ckconst" _istranslated="1">CHECK 约束</a>、<a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_createtable.html#dfltval" _istranslated="1">DEFAULT 子句</a>、<a href="https://www.sqlite.org/gencol.html" _istranslated="1">生成列</a>、<a href="https://www.sqlite.org/expridx.html" _istranslated="1">表达式索引</a>和/或<a href="https://www.sqlite.org/partialindex.html" _istranslated="1">部分索引</a>。此设置也可以使用
 <a href="https://www.sqlite.org/c3ref/db_config.html" _istranslated="1">sqlite3_db_config</a>（<a href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfigtrustedschema" _istranslated="1">db，SQLITE_DBCONFIG_TRUSTED_SCHEMA</a>,...）
 C 语言界面。</p><p _msttexthash="927339868" _msthash="558">为了保持向后兼容性，该设置为
 默认为 ON。关闭它有好处，而且大多数
 如果它已关闭，应用程序将不受影响。因此，
 建议所有应用程序在每个
 database 连接。</p><p><font _mstmutation="1" _msttexthash="229789079" _msthash="559"><a href="https://www.sqlite.org/compile.html#trusted_schema" _mstmutation="1" _istranslated="1">-DSQLITE_TRUSTED_SCHEMA=0</a> 编译时选项将导致
 此设置默认为 OFF。</font><a name="pragma_user_version"></a>
<h _id="pragma_user_version" style="display:none" _msttexthash="370032" _msthidden="1" _msthash="560"> PRAGMA user_version</h></p><hr>
      <p><font _mstmutation="1" _msttexthash="78280098" _msthash="561"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">user_version;<br _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">user_version = </b><i _mstmutation="1" _istranslated="1">整数 </i></font><b>;</b>

  
</p><p _msttexthash="1098376188" _msthash="562">user_version 编译指示将获取或设置
 <a href="https://www.sqlite.org/fileformat2.html#database_header" _istranslated="1">数据库标头</a>中偏移量为 60 处的 user-version 整数的值。user-version 是一个整数，即
 可供应用程序根据需要使用。SQLite
 不使用 user-version 本身。</p><p><font _mstmutation="1" _msttexthash="31919615" _msthash="563">另请参阅 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_application_id" _mstmutation="1" _istranslated="1">application_id pragma</a> 和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_schema_version" _mstmutation="1" _istranslated="1">schema_version pragma</a>。</font><a name="pragma_vdbe_addoptrace"></a>
<h _id="pragma_vdbe_addoptrace" style="display:none" _msttexthash="459472" _msthidden="1" _msthash="564"> PRAGMA vdbe_addoptrace</h></p><hr>
    <p><font _mstmutation="1" _msttexthash="27025635" _msthash="565"><b _mstmutation="1" _istranslated="1">PRAGMA vdbe_addoptrace = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="1737826610" _msthash="566">如果 SQLite 已使用 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> 编译时进行编译
 选项，则 vdbe_addoptrace pragma 可用于导致完整的
 VDBE作码在代码生成期间创建时显示。
 此功能用于调试 SQLite 本身。有关更多信息，请参阅 <a href="https://www.sqlite.org/vdbe.html#trace" _istranslated="1">VDBE 文档</a>
 信息。</p>

    
    <p style="background-color: #f0e0ff;" _msttexthash="223800174" _msthash="567">此 pragma 旨在用于调试 SQLite 本身。它
 仅在 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> compile-time 选项
 被使用。</p>
  
<a name="pragma_vdbe_debug"></a>
<h _id="pragma_vdbe_debug" style="display:none" _msttexthash="288275" _msthidden="1" _msthash="568"> PRAGMA vdbe_debug</h><hr>
    <p><font _mstmutation="1" _msttexthash="22418838" _msthash="569"><b _mstmutation="1" _istranslated="1">PRAGMA vdbe_debug = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="1723529041" _msthash="570">如果 SQLite 已使用 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> 编译时进行编译
 选项，则 vdbe_debug pragma 是其他三个
 仅限调试的 pragma：vdbe_addoptrace、vdbe_listing 和 vdbe_trace。
 此功能用于调试 SQLite 本身。有关更多信息，请参阅 <a href="https://www.sqlite.org/vdbe.html#trace" _istranslated="1">VDBE 文档</a>
 信息。</p>

    
    <p style="background-color: #f0e0ff;" _msttexthash="223800174" _msthash="571">此 pragma 旨在用于调试 SQLite 本身。它
 仅在 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> compile-time 选项
 被使用。</p>
  
<a name="pragma_vdbe_listing"></a>
<h _id="pragma_vdbe_listing" style="display:none" _msttexthash="360880" _msthidden="1" _msthash="572"> PRAGMA vdbe_listing</h><hr>
    <p><font _mstmutation="1" _msttexthash="24265683" _msthash="573"><b _mstmutation="1" _istranslated="1">PRAGMA vdbe_listing = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="4175665312" _msthash="574">如果 SQLite 已使用 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> 编译时进行编译
 选项，则 vdbe_listing pragma 可用于导致完整的
 要在 Standard 输出上显示的虚拟机作码列表
 ，因为每个语句都被评估。
 打开列表后，将打印程序的全部内容
 就在开始执行之前。声明
 在打印列表后正常执行。
 此功能用于调试 SQLite 本身。有关更多信息，请参阅 <a href="https://www.sqlite.org/vdbe.html#trace" _istranslated="1">VDBE 文档</a>
 信息。</p>

    
    <p style="background-color: #f0e0ff;" _msttexthash="223800174" _msthash="575">此 pragma 旨在用于调试 SQLite 本身。它
 仅在 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> compile-time 选项
 被使用。</p>
  
<a name="pragma_vdbe_trace"></a>
<h _id="pragma_vdbe_trace" style="display:none" _msttexthash="289484" _msthidden="1" _msthash="576"> PRAGMA vdbe_trace</h><hr>
    <p><font _mstmutation="1" _msttexthash="22420047" _msthash="577"><b _mstmutation="1" _istranslated="1">PRAGMA vdbe_trace = </b><i _mstmutation="1" _istranslated="1">布尔</i>值</font><b>;</b></p>

    <p _msttexthash="1685969389" _msthash="578">如果 SQLite 已使用 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> 编译时进行编译
 选项，则 vdbe_trace pragma 可用于导致虚拟机
 作码，以便在评估它们时打印在标准输出上。
 此功能用于调试 SQLite。有关更多信息，请参阅 <a href="https://www.sqlite.org/vdbe.html#trace" _istranslated="1">VDBE 文档</a>
 信息。</p>

    
    <p style="background-color: #f0e0ff;" _msttexthash="223800174" _msthash="579">此 pragma 旨在用于调试 SQLite 本身。它
 仅在 <a href="https://www.sqlite.org/compile.html#debug" _istranslated="1">SQLITE_DEBUG</a> compile-time 选项
 被使用。</p>
  
<a name="pragma_wal_autocheckpoint"></a>
<h _id="pragma_wal_autocheckpoint" style="display:none" _msttexthash="593086" _msthidden="1" _msthash="580"> PRAGMA wal_autocheckpoint</h><hr>
    <p><font _mstmutation="1" _msttexthash="2080455" _msthash="581"><b _mstmutation="1">PRAGMA wal_autocheckpoint;<br>
          PRAGMA wal_autocheckpoint=</b><i _mstmutation="1">N</i></font><b>;</b></p>

    <p _msttexthash="1680774927" _msthash="582">此 pragma 查询或设置<a href="https://www.sqlite.org/wal.html" _istranslated="1">预写日志</a><a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">自动检查点</a>间隔。
 启用<a href="https://www.sqlite.org/wal.html" _istranslated="1">预写日志</a>后（通过 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_mode" _istranslated="1">journal_mode 编译指示</a>），检查点将在
 预写日志的长度等于或超过 <i _istranslated="1">N</i> 页。
 将自动检查点大小设置为零或负值
 关闭自动检查点。</p>
    
    <p _msttexthash="439856209" _msthash="583">此 pragma 是 <a href="https://www.sqlite.org/c3ref/wal_autocheckpoint.html" _istranslated="1">sqlite3_wal_autocheckpoint（）</a> C 接口的包装器。
 所有自动检查点都是<a href="https://www.sqlite.org/c3ref/wal_checkpoint_v2.html" _istranslated="1">被动</a>的。</p>

    <p _msttexthash="130208832" _msthash="584">默认情况下，自动检查点启用，间隔为
 1000 或 <a href="https://www.sqlite.org/compile.html#default_wal_autocheckpoint" _istranslated="1">SQLITE_DEFAULT_WAL_AUTOCHECKPOINT</a>。</p>

<a name="pragma_wal_checkpoint"></a>
<h _id="pragma_wal_checkpoint" style="display:none" _msttexthash="431431" _msthidden="1" _msthash="585"> PRAGMA wal_checkpoint</h><hr>
    <p><font _mstmutation="1" _msttexthash="1229568210" _msthash="586"><b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">wal_checkpoint;</b><br _mstmutation="1" _istranslated="1"> <b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">wal_checkpoint（被动）;</b><br _mstmutation="1" _istranslated="1"> <b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">wal_checkpoint（已满）;</b><br _mstmutation="1" _istranslated="1"> <b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">wal_checkpoint（重启）;</b><br _mstmutation="1" _istranslated="1"> <b _mstmutation="1" _istranslated="1">PRAGMA </b><i _mstmutation="1" _istranslated="1">架构。</i><b _mstmutation="1" _istranslated="1">wal_checkpoint（截断）;</b></font>
   </p>

    <p _msttexthash="1892650864" _msthash="587">如果启用了<a href="https://www.sqlite.org/wal.html" _istranslated="1">预写日志</a>（通过 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/pragma.html#pragma_journal_mode" _istranslated="1">journal_mode 编译指示</a>），
 此 pragma 会导致 <a href="https://www.sqlite.org/wal.html#ckpt" _istranslated="1">checkpoint</a>作<i _istranslated="1">在 Database 上运行</i>，如果省略 <i _istranslated="1">database</i>，则在所有附加的数据库上运行。如果禁用<a href="https://www.sqlite.org/wal.html" _istranslated="1">了预写日志</a>模式，则此 pragma 是一个
 无害的无作。</p>

    <p _msttexthash="195372658" _msthash="588">调用此
 不带参数的 pragma 等效于调用 <a href="https://www.sqlite.org/c3ref/wal_checkpoint.html" _istranslated="1">sqlite3_wal_checkpoint（）</a> C 接口。</p><font _mstmutation="1" _msttexthash="395935319" _msthash="589">使用参数调用此 pragma 等效于使用与参数对应的<a href="https://www.sqlite.org/c3ref/c_checkpoint_full.html" _mstmutation="1" _istranslated="1">第 3 个参数</a>调用 <a href="https://www.sqlite.org/c3ref/wal_checkpoint_v2.html" _mstmutation="1" _istranslated="1">sqlite3_wal_checkpoint_v2（）</a> C 接口：</font><dl>
    <dt _msttexthash="5384457" _msthash="590">被动</dt><dd _msttexthash="1253049421" _msthash="591">检查点尽可能多的帧，而无需等待任何数据库
 读取器或写入器完成。如果日志中的所有帧都
 被执行检查点。此模式与调用 <a href="https://www.sqlite.org/c3ref/wal_checkpoint.html" _istranslated="1">sqlite3_wal_checkpoint（）</a> C 接口相同。<a href="https://www.sqlite.org/c3ref/busy_handler.html" _istranslated="1">busy-handler 回调</a>永远不会在
 此模式。</dd><dt _msttexthash="2583035" _msthash="592">满</dt><dd _msttexthash="2321859748" _msthash="593">此模式会阻止
 （调用 <a href="https://www.sqlite.org/c3ref/busy_handler.html" _istranslated="1">busy-handler 回调</a>）
 直到没有
 数据库写入器，并且所有读取器都从最新的数据库中读取
 快照。然后，它会对日志文件中的所有帧进行检查点检查，并将
 database 文件。FULL 会阻止并发写入器，而
 运行，但读者可以继续。</dd><dt _msttexthash="11376170" _msthash="594">重新启动</dt><dd _msttexthash="1963414856" _msthash="595">此模式的工作方式与 FULL 相同，但
 对它阻止的日志文件进行检查点作（调用 <a href="https://www.sqlite.org/c3ref/busy_handler.html" _istranslated="1">busy-handler 回调</a>）
 直到所有读取器都完成日志文件。这确保了
 下一个写入数据库文件的客户端将重新启动日志文件
 从一开始。RESTART 在
 running，但允许 reader 继续。</dd><dt _msttexthash="4993846" _msthash="596">截断</dt><dd _msttexthash="341994809" _msthash="597">此模式的工作方式与 RESTART 相同，其中
 此外，WAL 文件在成功后被截断为零字节
 完成。</dd></dl>


    <p _msttexthash="9993392604" _msthash="598">wal_checkpoint pragma 返回一行，其中包含三个
 整数列。第一列通常为 0，但将为
 1 如果 RESTART 或 FULL 或 TRUNCATE 检查点被阻止完成，
 例如，因为另一个线程或进程处于活动状态
 使用数据库。换句话说，如果
 对 <a href="https://www.sqlite.org/c3ref/wal_checkpoint_v2.html" _istranslated="1">sqlite3_wal_checkpoint_v2（）</a> 的等效调用将返回 <a href="https://www.sqlite.org/rescode.html#ok" _istranslated="1">SQLITE_OK</a>，如果等效调用返回 <a href="https://www.sqlite.org/rescode.html#busy" _istranslated="1">SQLITE_BUSY</a>，则返回 1。
 第二列是已修改的页面数
 写入预写日志文件。
 第三列是预写日志文件中的页数
 已成功移回位于
 检查点的结论。
 如果没有
 预写日志，例如，如果在数据库上调用此 pragma
 未处于 <a href="https://www.sqlite.org/wal.html" _istranslated="1">WAL 模式</a>的连接。</p>
<a name="pragma_writable_schema"></a>
<h _id="pragma_writable_schema" style="display:none" _msttexthash="461149" _msthidden="1" _msthash="599"> PRAGMA writable_schema</h><hr>
    <p _msttexthash="78674102" _msthash="600"><b _istranslated="1">PRAGMA writable_schema = </b><i _istranslated="1">布尔</i><b _istranslated="1">值;</b><br _istranslated="1"> <b _istranslated="1">PRAGMA writable_schema = 重置</b></p>

    <p><font _mstmutation="1" _msttexthash="4035876923" _msthash="601">当此 pragma 打开时，<a href="https://www.sqlite.org/c3ref/c_dbconfig_defensive.html#sqlitedbconfigdefensive" _mstmutation="1" _istranslated="1">SQLITE_DBCONFIG_DEFENSIVE</a> 标志
 处于关闭状态，则 <a href="https://www.sqlite.org/schematab.html" _mstmutation="1" _istranslated="1">sqlite_schema</a> 表
 可以使用普通的 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_update.html" _mstmutation="1" _istranslated="1">UPDATE、</a><a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_insert.html" _mstmutation="1" _istranslated="1">INSERT</a> 和 <a href="file:///E:/Code/VsStudio/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/Core/lang_delete.html" _mstmutation="1" _istranslated="1">DELETE</a> 语句进行更改。如果参数为 “RESET”，则架构写入为
 disabled（与 “PRAGMA writable_schema=OFF”） 一样，此外，
 schema 被重新加载。<span style="background-color: #ffff60;" _mstmutation="1" _istranslated="1"><b _istranslated="1">警告：</b>误用此编译指示很容易导致
 <a href="https://www.sqlite.org/howtocorrupt.html#cfgerr" _istranslated="1">损坏的数据库文件</a>。</span></font>

</p><hr>
<p align="center"><small><i _msttexthash="77568335" _msthash="602">此页面最后修改于 <a href="https://sqlite.org/docsrc/honeypot" id="mtimelink" data-href="https://sqlite.org/docsrc/finfo/pages/pragma.in?m=c5681f40cb" _istranslated="1">2024-04-16 16：29：07</a> UTC</i></small></p>

</body></html>