
<!-- saved from url=(0179)file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members.html -->
<html dir="LTR" xmlns:ndoc="urn:ndoc-schema"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta content="history" name="save">
    <meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5">
    <title>ISQLiteNativeModule Members</title>
    </head><body id="bodyID" class="dtBODY"><xml>
    </xml>
    <link rel="stylesheet" type="text/css" href="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/MSDN.css">
  
  
    <div id="nsbanner">
      <div id="bannerrow1">
        <table class="bannerparthead" cellspacing="0">
          <tbody><tr id="hdr">
            <td class="runninghead" _msttexthash="28553707" _msthash="0">SQLite ADO.NET 提供程序</td>
            <td class="product">
            </td>
          </tr>
        </tbody></table>
      </div>
      <div id="TitleRow">
        <h1 class="dtH1" _msttexthash="16462186" _msthash="1">ISQLiteNativeModule 成员</h1>
      </div>
    </div>
    <div id="nstext">
      <p>
        <a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.html" _msttexthash="22461270" _msthash="2">ISQLiteNativeModule 概述</a>
      </p>
      <h4 class="dtH4" _msttexthash="17526587" _msthash="3">公共实例方法</h4>
      <div class="tablediv">
        <table class="dtTABLE" cellspacing="0">
<tbody><tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xBegin.html">xBegin</a></td><td width="50%"><pre class="code">int (*xBegin)(sqlite3_vtab *pVTab);
</pre> <font _mstmutation="1" _msttexthash="4280666091" _msthash="74">此方法在虚拟 table 上开始事务。此方法是可选的。sqlite3_module 的 xBegin 指针可能为 NULL。此方法后跟对 xCommit 或 xRollback 方法的一次调用。虚拟表事务不会嵌套，因此，如果不对 xCommit 或 xRollback 进行干预调用，则不会在单个虚拟表上多次调用 xBegin 方法。在 xBegin 和相应的 xCommit 或 xRollback 之间，可能会发生对其他方法的多次调用。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xBestIndex.html">xBestIndex</a></td><td width="50%"> <font _mstmutation="1" _msttexthash="565820138" _msthash="73">SQLite 使用虚拟表模块的 xBestIndex 方法来确定访问虚拟表的最佳方式。xBestIndex 方法有一个如下所示的原型：</font> <pre class="code">int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
</pre> <font _mstmutation="1" _msttexthash="1919270717" _msthash="72">SQLite 核心通过填写 sqlite3_index_info 结构的某些字段并将指向该结构的指针作为第二个参数传递给 xBestIndex 来与 xBestIndex 方法进行通信。xBestIndex 方法填充此结构的其他字段，以形成回复。sqlite3_index_info结构如下所示：</font> <pre class="code">struct sqlite3_index_info {
  /* Inputs */
  const int nConstraint;     /* Number of entries in aConstraint */
  const struct sqlite3_index_constraint {
     int iColumn;              /* Column constrained.  -1 for ROWID */
     unsigned char op;         /* Constraint operator */
     unsigned char usable;     /* True if this constraint is usable */
     int iTermOffset;          /* Used internally - xBestIndex should ignore */
  } *const aConstraint;      /* Table of WHERE clause constraints */
  const int nOrderBy;        /* Number of terms in the ORDER BY clause */
  const struct sqlite3_index_orderby {
     int iColumn;              /* Column number */
     unsigned char desc;       /* True for DESC.  False for ASC. */
  } *const aOrderBy;         /* The ORDER BY clause */
  /* Outputs */
  struct sqlite3_index_constraint_usage {
    int argvIndex;           /* if &gt;0, constraint is part of argv to xFilter */
    unsigned char omit;      /* Do not code a test for this constraint */
  } *const aConstraintUsage;
  int idxNum;                /* Number used to identify the index */
  char *idxStr;              /* String, possibly obtained from sqlite3_malloc */
  int needToFreeIdxStr;      /* Free idxStr using sqlite3_free() if true */
  int orderByConsumed;       /* True if output is already ordered */
  double estimatedCost;      /* Estimated cost of using this index */
  <b>/* Fields below are only available in SQLite 3.8.2 and later */</b>
  sqlite3_int64 estimatedRows;    /* Estimated number of rows returned */
  <b>/* Fields below are only available in SQLite 3.9.0 and later */</b>
  int idxFlags;              /* Mask of SQLITE_INDEX_SCAN_* flags */
  <b>/* Fields below are only available in SQLite 3.10.0 and later */</b>
  sqlite3_uint64 colUsed;    /* Input: Mask of columns used by statement */
};
</pre> <font _mstmutation="1" _msttexthash="7317584937" _msthash="71">请注意 “estimatedRows”、“idxFlags” 和 colUsed 字段上的警告。这些字段分别随 SQLite 版本 3.8.2、3.9.0 和 3.10.0 一起添加。读取或写入这些字段的任何扩展都必须首先检查正在使用的 SQLite 库的版本是否大于或等于适当的版本 - 可能将从 sqlite3_libversion_number（） 返回的值与常量 3008002、3009000 和/或 3010000 进行比较。尝试在旧版本的 SQLite 创建的 sqlite3_index_info 结构中访问这些字段的结果是未定义的。此外，还有一些定义的常量：</font> <pre class="code">#define SQLITE_INDEX_CONSTRAINT_EQ         2
#define SQLITE_INDEX_CONSTRAINT_GT         4
#define SQLITE_INDEX_CONSTRAINT_LE         8
#define SQLITE_INDEX_CONSTRAINT_LT        16
#define SQLITE_INDEX_CONSTRAINT_GE        32
#define SQLITE_INDEX_CONSTRAINT_MATCH     64
#define SQLITE_INDEX_CONSTRAINT_LIKE      65  /* 3.10.0 and later */
#define SQLITE_INDEX_CONSTRAINT_GLOB      66  /* 3.10.0 and later */
#define SQLITE_INDEX_CONSTRAINT_REGEXP    67  /* 3.10.0 and later */
#define SQLITE_INDEX_CONSTRAINT_NE        68  /* 3.21.0 and later */
#define SQLITE_INDEX_CONSTRAINT_ISNOT     69  /* 3.21.0 and later */
#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70  /* 3.21.0 and later */
#define SQLITE_INDEX_CONSTRAINT_ISNULL    71  /* 3.21.0 and later */
#define SQLITE_INDEX_CONSTRAINT_IS        72  /* 3.21.0 and later */
#define SQLITE_INDEX_CONSTRAINT_LIMIT     73  /* 3.38.0 and later */
#define SQLITE_INDEX_CONSTRAINT_OFFSET    74  /* 3.38.0 and later */
#define SQLITE_INDEX_CONSTRAINT_FUNCTION 150  /* 3.25.0 and later */
#define SQLITE_INDEX_SCAN_UNIQUE           1  /* Scan visits at most 1 row */
</pre> <font _mstmutation="1" _msttexthash="440287731" _msthash="70">使用 sqlite3_vtab_collation（） 接口查找评估第 i 个约束时应使用的整理序列的名称：</font> <pre class="code">const char *sqlite3_vtab_collation(sqlite3_index_info*, int i);
</pre> <font _mstmutation="1" _msttexthash="76451381435" _msthash="69">SQLite 核心在编译涉及虚拟表的查询时调用 xBestIndex 方法。换句话说，SQLite 在运行 sqlite3_prepare（） 或等效方法时调用此方法。通过调用此方法，SQLite 核心向虚拟表表示它需要访问虚拟表中行的某些子集，并且它想知道执行该访问的最有效方法。xBestIndex 方法回复 SQLite 核心随后可以用来对虚拟表进行有效搜索的信息。在编译单个 SQL 查询时，SQLite 核心可能会多次调用 xBestIndex，并在 sqlite3_index_info 中设置不同。然后，SQLite 核心将选择似乎可提供最佳性能的组合。在调用此方法之前，SQLite 核心会使用有关当前尝试处理的查询的信息初始化 sqlite3_index_info 结构的实例。此信息主要来自查询的 WHERE 子句和 ORDER BY 或 GROUP BY 子句，如果查询是联接，则还来自任何 ON 或 USING 子句。SQLite 核心提供给 xBestIndex 方法的信息保存在标记为“Inputs”的结构部分中。“Outputs” 部分初始化为零。sqlite3_index_info结构中的信息是短暂的，一旦 xBestIndex 方法返回，就可以被覆盖或解除分配。如果 xBestIndex 方法需要记住 sqlite3_index_info 结构的任何部分，则应创建一个副本。必须注意将副本存储在将要解除分配的位置，例如在 needToFreeIdxStr 设置为 1 的 idxStr 字段中。请注意，xBestIndex 将始终在 xFilter 之前调用，因为 xBestIndex 的 idxNum 和 idxStr 输出是 xFilter 的必需输入。但是，不能保证在成功执行 xBestIndex 后将调用 xFilter。每个虚拟表实现都需要 xBestIndex 方法。SQLite 核心尝试与虚拟表通信的主要内容是可用于限制需要搜索的行数的约束。aConstraint[] 数组包含每个约束的一个条目。该数组中将有 nConstraint 条目。每个约束通常对应于 WHERE 子句或 USING 或 ON 子句中的一个术语，其格式为</font> <pre class="code">     column  OP  EXPR
</pre> <font _mstmutation="1" _msttexthash="831016589" _msthash="68">其中 “column” 是虚拟表中的列，OP 是类似于 “=” 或 “&lt;” 的运算符，而 EXPR 是任意表达式。因此，例如，如果 WHERE 子句包含如下术语：</font> <pre class="code">a = 5
</pre> <font _mstmutation="1" _msttexthash="1990429987" _msthash="67">然后，其中一个约束将位于运算符为 “=” 且表达式为 “5” 的 “a” 列上。约束不需要具有 WHERE 子句的文字表示形式。查询优化器可能会对 WHERE 子句进行转换，以便提取尽可能多的约束。因此，例如，如果 WHERE 子句包含如下内容：</font> <pre class="code">x BETWEEN 10 AND 100 AND 999&gt;y
</pre> <font _mstmutation="1" _msttexthash="132430090" _msthash="66">查询优化器可能会将其转换为三个单独的约束：</font> <pre class="code">x &gt;= 10
x &lt;= 100
y &lt; 999
</pre> <font _mstmutation="1" _msttexthash="9110808759" _msthash="65">对于每个此类约束，aConstraint[].iColumn 字段指示在约束的左侧显示哪一列。虚拟表的第一列是第 0 列。虚拟表的 rowid 为列 -1。aConstraint[].op 字段指示使用哪个运算符。SQLITE_INDEX_CONSTRAINT_* 常量将整数常量映射到运算符值。列按照在 xCreate 或 xConnect 方法中调用 sqlite3_declare_vtab（） 定义的顺序出现。在确定列索引时，将对隐藏的列进行计数。如果定义了虚拟表的 xFindFunction（） 方法，并且 xFindFunction（） 有时返回 SQLITE_INDEX_CONSTRAINT_FUNCTION 或更大，则约束也可能是以下形式：</font> <pre class="code">     FUNCTION( column, EXPR)
</pre> <font _mstmutation="1" _msttexthash="58243208335" _msthash="64">在这种情况下，aConstraint[].op 值与 xFindFunction（） 为 FUNCTION 返回的值相同。aConstraint[] 数组包含有关应用于虚拟表的所有约束的信息。但是，由于表中在联接中的排序方式，某些约束可能不可用。因此，xBestIndex 方法必须只考虑具有 aConstraint[].usable 标志（为 true）的约束。除了 WHERE 子句约束之外，SQLite 核心还告诉 xBestIndex 方法有关 ORDER BY 子句的信息。（在聚合查询中，SQLite 核心可能会放入 GROUP BY 子句信息来代替 ORDER BY 子句信息，但这一事实不应对 xBestIndex 方法产生任何影响。如果 ORDER BY 子句的所有术语都是虚拟表中的列，则 nOrderBy 将是 ORDER BY 子句中的术语数，aOrderBy[] 数组将标识 order by 子句中每个术语的列，以及该列是 ASC 还是 DESC。在 SQLite 版本 3.10.0 （2016-01-06） 及更高版本中，colUsed 字段可用于指示正在准备的语句实际使用虚拟表的哪些字段。如果设置了 colUsed 的最低位，则表示使用第一列。第二个最低位对应于第二列。等等。如果设置了 colUsed 的最高有效位，则意味着使用前 63 列以外的一个或多个列。如果 xFilter 方法需要列使用信息，则必须将所需的位编码到输出 idxNum 字段或 idxStr 内容中。对于 LIKE、GLOB、REGEXP 和 MATCH 运算符，aConstraint[].iColumn 值是作为运算符左作数的虚拟表列。但是，如果这些运算符表示为函数调用而不是运算符，则 aConstraint[].iColumn 值将引用作为该函数的第二个参数的虚拟表列：</font> <pre class="code">LIKE(<i xmlns="urn:ndoc-schema">EXPR</i>, <i xmlns="urn:ndoc-schema">column</i>)<br>
GLOB(<i xmlns="urn:ndoc-schema">EXPR</i>, <i xmlns="urn:ndoc-schema">column</i>)<br>
REGEXP(<i xmlns="urn:ndoc-schema">EXPR</i>, <i xmlns="urn:ndoc-schema">column</i>)<br>
MATCH(<i xmlns="urn:ndoc-schema">EXPR</i>, <i xmlns="urn:ndoc-schema">column</i>)<br></pre> <font _mstmutation="1" _msttexthash="255044881" _msthash="63">因此，就 xBestIndex（） 方法而言，以下两种形式是等效的：</font> <pre class="code"><i xmlns="urn:ndoc-schema">column</i> LIKE <i xmlns="urn:ndoc-schema">EXPR</i><br>
      LIKE(<i xmlns="urn:ndoc-schema">EXPR</i>,<i xmlns="urn:ndoc-schema">column</i>)
      </pre> <font _mstmutation="1" _msttexthash="450308790646" _msthash="56">这种查看函数的第二个参数的特殊行为仅发生在 LIKE、GLOB、REGEXP 和 MATCH 函数中。对于所有其他函数，aConstraint[].iColumn 值引用函数的第一个参数。但是，LIKE、GLOB、REGEXP 和 MATCH 的这一特殊功能不适用于 xFindFunction（） 方法。xFindFunction（） 方法始终从 LIKE、GLOB、REGEXP 或 MATCH 运算符的左作数上键，但从第一个参数上键到这些运算符的函数调用等效项。当 aConstraint[].op 是 SQLITE_INDEX_CONSTRAINT_LIMIT 或 SQLITE_INDEX_CONSTRAINT_OFFSET 之一时，这表示使用虚拟表的 SQL 查询语句上存在 LIMIT 或 OFFSET 子句。LIMIT 和 OFFSET 运算符没有左作数，因此当 aConstraint[].op 是 SQLITE_INDEX_CONSTRAINT_LIMIT 或 SQLITE_INDEX_CONSTRAINT_OFFSET 之一时，aConstraint[].iColumn 值没有意义，不应使用。sqlite3_vtab_rhs_value（） 接口可用于尝试访问 constraint 的右侧作数。但是，在运行 xBestIndex 方法时，右侧运算符的值可能未知，因此 sqlite3_vtab_rhs_value（） 调用可能不会成功。通常，约束的右作数仅在 xBestIndex 中编码为 Literal 值时才可用于 xBestIndex。如果将正确的作数编码为表达式或主机参数，则 xBestIndex 可能无法访问它。某些运算符（如 SQLITE_INDEX_CONSTRAINT_ISNULL 和 SQLITE_INDEX_CONSTRAINT_ISNOTNULL）没有右作数。sqlite3_vtab_rhs_value（） 接口始终返回此类运算符的 SQLITE_NOTFOUND。鉴于上述所有信息，xBestIndex 方法的工作是找出搜索虚拟表的最佳方法。xBestIndex 方法通过 idxNum 和 idxStr 字段将索引策略传达给 xFilter 方法。就 SQLite 核心而言，idxNum 值和 idxStr 字符串内容是任意的，只要 xBestIndex 和 xFilter 就该含义达成一致，就可以具有任何含义。SQLite 核心只是将信息从 xBestIndex 复制到 xFilter 方法，仅假设通过 idxStr 引用的 char 序列是 NUL 终止的。idxStr 值可以是从 SQLite 内存分配函数（如 sqlite3_mprintf（） ）获取的字符串。如果是这种情况，则必须将 needToFreeIdxStr 标志设置为 true，以便 SQLite 核心在完成该字符串后知道在该字符串上调用 sqlite3_free（），从而避免内存泄漏。idxStr 值也可以是静态常量字符串，在这种情况下，needToFreeIdxStr 布尔值应保持为 false。estimatedCost 字段应设置为对虚拟表执行此查询所需的估计磁盘访问作数。SQLite 核心通常会使用不同的约束多次调用 xBestIndex，获得多个成本估算，然后选择给出最低估算的查询计划。SQLite 核心在调用 xBestIndex 之前将 estimatedCost 初始化为非常大的值，因此，如果 xBestIndex 确定当前参数组合是不需要的，它可以保持 estimatedCost 字段不变，以阻止其使用。如果 SQLite 的当前版本是 3.8.2 或更高版本，则可以将 estimatedRows 字段设置为建议的查询计划返回的行数的估计值。如果此值不明确itly set，则使用默认估计值 25 行。如果 SQLite 的当前版本是 3.9.0 或更高版本，则 idxFlags 字段可以设置为 SQLITE_INDEX_SCAN_UNIQUE，以指示给定输入约束的虚拟表将仅返回零行或一行。idxFlags 字段的其他位可能会在更高版本的 SQLite 中被理解。aConstraintUsage[] 数组包含 sqlite3_index_info 结构的 inputs 部分中的每个 nConstraint 约束的一个元素。xBestIndex 使用 aConstraintUsage[] 数组来告诉核心它如何使用约束。xBestIndex 方法可以将 aConstraintUsage[].argvIndex 条目设置为大于零的值。只有一个条目应设置为 1，另一个条目设置为 2，另一个条目设置为 3，依此类推，直到 xBestIndex 方法所需的数量或数量。然后，相应约束的 EXPR 将作为 argv[] 参数传递给 xFilter。例如，如果 aConstraint[3].argvIndex 设置为 1，则在调用 xFilter 时，传递给 xFilter 的 argv[0] 将具有 aConstraint[3] 约束的 EXPR 值。默认情况下，SQLite 会生成字节码，该字节码将仔细检查虚拟表每一行上的所有约束，以验证它们是否得到满足。如果虚拟表可以保证始终满足约束，则它可以尝试通过设置 aConstraintUsage[].omit 来禁止该双重检查。但是，除了一些例外，这只是一个提示，不能保证会抑制 constraint 的冗余检查。要点：</font><ul><li _msttexthash="2324095501" _msthash="57">仅当约束的 argvIndex 值大于 0 且小于或等于 16 时，才遵循 omit 标志。对于未将其右作数传递到 xFilter 方法中的约束，永远不会禁止约束检查。当前实现只能抑制传递给 xFilter 的前 16 个值的冗余约束检查，尽管该限制在未来版本中可能会增加。</li><li _msttexthash="5076129058" _msthash="58">只要 argvIndex 大于 0，SQLITE_INDEX_CONSTRAINT_OFFSET约束始终遵循 omit 标志。在SQLITE_INDEX_CONSTRAINT_OFFSET约束上设置 omit 标志向 SQLite 表明虚拟表本身将抑制输出的前 N 行，其中 N 是 OFFSET 运算符的正确作数。如果虚拟表实现在 SQLITE_INDEX_CONSTRAINT_OFFSET 约束上设置了 omit，但随后无法抑制输出的前 N 行，则整个查询将导致不正确的答案。</li></ul><font _mstmutation="1" _msttexthash="101753365909" _msthash="59">如果虚拟表将按照 ORDER BY 子句指定的顺序输出行，则 orderByConsumed 标志可以设置为 true。如果输出未自动按正确的顺序排列，则必须将 orderByConsumed 保留为其默认的 false 设置。这将向 SQLite 核心表明，在数据从虚拟表中出来后，它需要对数据进行单独的排序传递。设置 orderByConsumed 是一种优化。如果 orderByConsumed 保留为默认值 （0），则查询将始终获得正确答案。如果设置了 orderByConsumed ，则可以避免不必要的排序作，从而加快查询速度，但错误地设置 orderByConsumed 可能会导致答案错误。建议新的虚拟表实现最初不设置 orderByConsumed 值，然后在已知其他所有内容都正常工作后，返回并尝试通过在适当的情况下设置 orderByConsumed 进行优化。有时，即使虚拟表的输出不严格按照 nOrderBy 和 aOrderBy 指定的顺序，也可以安全地设置 orderByConsumed 标志。如果 sqlite3_vtab_distinct（） 接口返回 1 或 2，则表示可以放宽排序。有关更多信息，请参阅有关 sqlite3_vtab_distinct（） 的文档。xBestIndex 方法应在成功时返回 SQLITE_OK。如果发生任何类型的致命错误，则应返回相应的错误代码（例如：SQLITE_NOMEM）。如果 xBestIndex 返回 SQLITE_CONSTRAINT，则不表示存在错误。相反，SQLITE_CONSTRAINT 表示指定的 Importing 参数的特定组合不足以使虚拟 table 完成其工作。这在逻辑上与将 estimatedCost 设置为无穷大相同。如果对特定查询计划的 xBestIndex 的每次调用都返回 SQLITE_CONSTRAINT，则意味着无法安全地使用虚拟表，并且 sqlite3_prepare（） 调用将失败，并显示“no query solution”错误。从 xBestIndex 返回的 SQLITE_CONSTRAINT 对于具有所需参数的表值函数非常有用。如果其中一个必需参数的 aConstraint[].usable 字段为 false，则 xBestIndex 方法应返回 SQLITE_CONSTRAINT。如果 required 字段根本没有出现在 aConstraint[] 数组中，则意味着输入 SQL 中省略了相应的参数。在这种情况下，xBestIndex 应在 pVTab-&gt;zErrMsg 中设置错误消息并返回 SQLITE_ERROR。总结一下：</font><ol><li _msttexthash="80069509" _msthash="60">必需参数的 aConstraint[].usable 值为 false <big xmlns="urn:ndoc-schema" _istranslated="1">→</big>返回 SQLITE_CONSTRAINT。</li><li _msttexthash="346365630" _msthash="61">必需参数未出现在 aConstraint[] 数组中的任何位置<big xmlns="urn:ndoc-schema" _istranslated="1">→</big>在 pVTab-&gt;zErrMsg 中设置错误消息并返回SQLITE_ERROR</li></ol><font _mstmutation="1" _msttexthash="201116110" _msthash="62">以下示例将更好地说明如何使用 SQLITE_CONSTRAINT 作为 xBestIndex 的返回值：</font> <pre class="code">SELECT * FROM realtab, tablevaluedfunc(realtab.x);
</pre> <font _mstmutation="1" _msttexthash="424965580" _msthash="55">假设 “tablevaluedfunc” 的第一个隐藏列是 “param1”，则上面的查询在语义上等同于此：</font> <pre class="code">SELECT * FROM realtab, tablevaluedfunc
 WHERE tablevaluedfunc.param1 = realtab.x;
</pre> <font _mstmutation="1" _msttexthash="375581765" _msthash="51">查询计划程序必须在此查询的许多可能实现之间做出决定，但特别需要注意两个计划：</font><ol><li _msttexthash="248581476" _msthash="52">扫描 realtab 的所有行，对于每一行，在 tablevaluedfunc 中查找 param1 等于 realtab.x 的行</li><li _msttexthash="262771912" _msthash="53">扫描 tablevalued func 的所有行，并在 realtab 中查找 x 等于 tablevaluedfunc.param1 的每一行。</li></ol><font _mstmutation="1" _msttexthash="9432576855" _msthash="54">对于上述每个潜在计划，将调用一次 xBestIndex 方法。对于计划 1，param1 列上 SQLITE_CONSTRAINT_EQ 约束的 aConstraint[].usable 标志将为 true，因为 “param1 = ？” 约束的右侧值是已知的，因为它是由外部 realtab 循环确定的。但对于计划 2，“param1 = ？”的 aConstraint[].usable 标志将为 false，因为右侧值由内部循环确定，因此是一个未知量。由于 param1 是表值函数的必需输入，因此 xBestIndex 方法在显示计划 2 时应返回 SQLITE_CONSTRAINT，指示缺少必需的输入。这会强制查询计划程序选择计划 1。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xClose.html">xClose</a></td><td width="50%"><pre class="code">int (*xClose)(sqlite3_vtab_cursor*);
</pre> <font _mstmutation="1" _msttexthash="3044009410" _msthash="50">xClose 方法将关闭以前由 xOpen 打开的游标。SQLite 核心将始终为使用 xOpen 打开的每个游标调用 xClose 一次。此方法必须释放相应 xOpen 调用分配的所有资源。即使该例程返回错误，也不会再次调用该例程。SQLite 核心在关闭后将不再使用 sqlite3_vtab_cursor。每个虚拟表实现都需要 xClose 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xColumn.html">xColumn</a></td><td width="50%"><pre class="code">int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int N);
</pre> <font _mstmutation="1" _msttexthash="813483541" _msthash="38">SQLite 核心调用此方法以查找当前行的第 N 列的值。N 从 0 开始，因此第一列的编号为 0。xColumn 方法可以使用以下接口之一将其结果返回给 SQLite：</font><ul><li _msttexthash="45396143" _msthash="39">sqlite3_result_blob（）</li><li _msttexthash="48866441" _msthash="40">sqlite3_result_double（）</li><li _msttexthash="43670952" _msthash="41">sqlite3_result_int（）</li><li _msttexthash="47101080" _msthash="42">sqlite3_result_int64（）</li><li _msttexthash="45404580" _msthash="43">sqlite3_result_null（）</li><li _msttexthash="45407856" _msthash="44">sqlite3_result_text（）</li><li _msttexthash="48838374" _msthash="45">sqlite3_result_text16（）</li><li _msttexthash="52310765" _msthash="46">sqlite3_result_text16le（）</li><li _msttexthash="52307125" _msthash="47">sqlite3_result_text16be（）</li><li _msttexthash="52344461" _msthash="48">sqlite3_result_zeroblob（）</li></ul><font _mstmutation="1" _msttexthash="2544364953" _msthash="49">如果 xColumn 方法实现未调用上述任何函数，则列的值默认为 SQL NULL。要引发错误，xColumn 方法应使用 result_text（） 方法之一来设置错误消息文本，然后返回相应的错误代码。xColumn 方法必须在成功时返回 SQLITE_OK。每个虚拟表实现都需要 xColumn 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xCommit.html">xCommit</a></td><td width="50%"><pre class="code">int (*xCommit)(sqlite3_vtab *pVTab);
</pre> <font _mstmutation="1" _msttexthash="748472049" _msthash="37">此方法会导致虚拟表事务提交。此方法是可选的。sqlite3_module 的 xCommit 指针可能为 NULL。对此方法的调用始终在对 xBegin 和 xSync 的先前调用之后。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xConnect.html">xConnect</a></td><td width="50%"><pre class="code">int (*xConnect)(sqlite3*, void *pAux,
             int argc, char *const*argv,
             sqlite3_vtab **ppVTab,
             char **pzErr);
</pre> <font _mstmutation="1" _msttexthash="83860318581" _msthash="36">xConnect 方法与 xCreate 非常相似。它具有相同的参数，并像 xCreate 一样构建一个新的 sqlite3_vtab 结构。它还必须像 xCreate 一样调用 sqlite3_declare_vtab（）。它还应该进行与 xCreate 相同的所有 sqlite3_vtab_config（） 调用。区别在于，调用 xConnect 是为了建立与现有虚拟表的新连接，而调用 xCreate 是为了从头开始创建新的虚拟表。仅当虚拟表具有某种必须在首次创建虚拟表时初始化的后备存储时，xCreate 和 xConnect 方法才不同。xCreate 方法创建并初始化后备存储。xConnect 方法只连接到现有的后备存储。当 xCreate 和 xConnect 相同时，该表是同名的虚拟表。例如，考虑一个虚拟表实现，它提供对磁盘上现有逗号分隔值 （CSV） 文件的只读访问权限。不需要为此类虚拟表创建或初始化后备存储（因为 CSV 文件已存在于磁盘上），因此该模块的 xCreate 和 xConnect 方法将相同。另一个示例是实现全文索引的虚拟表。xCreate 方法必须创建并初始化数据结构，以保存该索引的字典和发布列表。另一方面，xConnect 方法只需查找和使用由先前 xCreate 调用创建的现有字典和发布列表。如果 xConnect 方法成功创建新的虚拟表，则必须返回 SQLITE_OK，如果未成功，则必须返回 SQLITE_ERROR。如果不成功，则不得分配 sqlite3_vtab 结构。如果不成功，可以选择在 *pzErr 中返回错误消息。必须使用 SQLite 内存分配函数（如 sqlite3_malloc（） 或 sqlite3_mprintf（） ）分配保存错误消息字符串的空间，因为 SQLite 核心将在错误报告给应用程序后尝试使用 sqlite3_free（） 释放空间。每个虚拟表实现都需要 xConnect 方法，但如果虚拟表不需要初始化后备存储，则 sqlite3_module 对象的 xCreate 和 xConnect 指针可能指向同一函数。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xCreate.html">xCreate</a></td><td width="50%"><pre class="code">int (*xCreate)(sqlite3 *db, void *pAux,
             int argc, char *const*argv,
             sqlite3_vtab **ppVTab,
             char **pzErr);
</pre> <font _mstmutation="1" _msttexthash="62760961510" _msthash="35">调用 xCreate 方法以创建虚拟表的新实例，以响应 CREATE VIRTUAL TABLE 语句。如果 xCreate 方法与 xConnect 方法相同，则虚拟表是同名虚拟表。如果省略 xCreate 方法（如果它是 NULL 指针），则虚拟表是仅同名的虚拟表。db 参数是指向正在执行 CREATE VIRTUAL TABLE 语句的 SQLite 数据库连接的指针。pAux 参数是 Client 端数据指针的副本，该指针是注册虚拟 table 模块的 sqlite3_create_module（） 或 sqlite3_create_module_v2（） 调用的第四个参数。argv 参数是指向以 null 结尾的字符串的 argc 指针数组。第一个字符串 argv[0] 是正在调用的模块的名称。模块名称是作为 sqlite3_create_module（） 的第二个参数和正在运行的 CREATE VIRTUAL TABLE 语句的 USING 子句的参数提供的名称。第二个 argv[1] 是正在其中创建新虚拟表的数据库的名称。对于主数据库，数据库名称为 “main”，对于 TEMP 数据库，数据库名称为 “temp”，对于附加的数据库，则为 ATTACH 语句末尾给出的名称。数组的第三个元素 argv[2] 是新虚拟表的名称，在 CREATE VIRTUAL TABLE 语句中的 TABLE 关键字后面指定。如果存在，则 argv[] 数组中的第四个和后续字符串将参数报告给 CREATE VIRTUAL TABLE 语句中的模块名称。此方法的工作是构造新的虚拟表对象 （sqlite3_vtab对象） 并在 *ppVTab 中返回指向它的指针。作为创建新sqlite3_vtab结构任务的一部分，此方法<u xmlns="urn:ndoc-schema" _mstmutation="1" _istranslated="1">必须</u>调用 sqlite3_declare_vtab（） 来告诉 SQLite 核心有关虚拟表中的列和数据类型的信息。sqlite3_declare_vtab（） API 具有以下原型：</font> <pre class="code">int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable)
</pre> <font _mstmutation="1" _msttexthash="12928987786" _msthash="34">sqlite3_declare_vtab（） 的第一个参数必须与此方法的第一个参数是相同的数据库连接指针。sqlite3_declare_vtab（） 的第二个参数必须是一个以零结尾的 UTF-8 字符串，该字符串包含格式正确的 CREATE TABLE 语句，该语句定义虚拟表中的列及其数据类型。此 CREATE TABLE 语句中的表名称将被忽略，所有约束也是如此。只有列名和数据类型才重要。CREATE TABLE 语句字符串不需要保存在持久内存中。一旦 sqlite3_declare_vtab（） 例程返回，就可以释放和/或重用该字符串。xConnect 方法还可以选择通过对 sqlite3_vtab_config（） 接口进行一次或多次调用来请求虚拟表的特殊功能：</font> <pre class="code">int sqlite3_vtab_config(sqlite3 *db, int op, ...);
</pre> <font _mstmutation="1" _msttexthash="75724061634" _msthash="29">对 sqlite3_vtab_config（） 的调用是可选的。但为了获得最大的安全性，如果虚拟表不会从触发器或视图内部使用，建议虚拟表实现调用 “sqlite3_vtab_config（db， SQLITE_VTAB_DIRECTONLY）”。xCreate 方法不需要初始化 sqlite3_vtab 对象的 pModule、nRef 和 zErrMsg 字段。SQLite 核心将处理这些琐事。如果 xCreate 成功创建新的虚拟表，则应返回 SQLITE_OK，如果未成功，则应返回 SQLITE_ERROR。如果不成功，则不得分配 sqlite3_vtab 结构。如果不成功，可以选择在 *pzErr 中返回错误消息。必须使用 SQLite 内存分配函数（如 sqlite3_malloc（） 或 sqlite3_mprintf（） ）分配保存错误消息字符串的空间，因为 SQLite 核心将在错误报告给应用程序后尝试使用 sqlite3_free（） 释放空间。如果省略 xCreate 方法（保留为 NULL 指针），则虚拟表是仅同名的虚拟表。无法使用 CREATE VIRTUAL TABLE 创建虚拟表的新实例，并且只能通过其模块名称使用虚拟表。请注意，3.9.0 （2015-10-14） 之前的 SQLite 版本无法理解仅同名虚拟表，如果尝试对仅同名虚拟表执行 CREATE VIRTUAL TABLE，则会出现段错误，因为 xCreate 方法未检查 null。如果 xCreate 方法与 xConnect 方法的指针完全相同，则表示虚拟表不需要初始化后备存储。这样的虚拟表可以用作同名虚拟表，也可以使用 CREATE VIRTUAL TABLE 作为命名虚拟表，也可以用作两者。如果列数据类型包含特殊关键字 “HIDDEN” （大小写字母的任意组合），则该关键字将从列数据类型名称中省略，并且该列在内部标记为隐藏列。隐藏列与普通列有三个不同：</font><ul><li _msttexthash="168458706" _msthash="30">隐藏的列未在 “PRAGMA table_info” 返回的数据集中列出，</li><li _msttexthash="199132505" _msthash="31">隐藏列不包括在 SELECT 结果集中的 “*” 表达式的扩展中，并且</li><li _msttexthash="205235680" _msthash="32">隐藏列不包括在缺少显式列列表的 INSERT 语句使用的隐式列列表中。</li></ul><font _mstmutation="1" _msttexthash="159478059" _msthash="33">例如，如果将以下 SQL 传递给 sqlite3_declare_vtab（）：</font> <pre class="code">CREATE TABLE x(a HIDDEN VARCHAR(12), b INTEGER, c INTEGER Hidden);
</pre> <font _mstmutation="1" _msttexthash="7581433249" _msthash="28">然后，将创建具有两个隐藏列的虚拟表，数据类型为 “VARCHAR（12）” 和 “INTEGER”。在FTS3虚拟表实施中可以看到隐藏列的一个示例，其中每个FTS虚拟表都包含一个FTS隐藏列，用于将信息从虚拟表传递到FTS辅助功能和FTS MATCH运算符。包含隐藏列的虚拟表可以像 SELECT 语句的 FROM 子句中的表值函数一样使用。表值函数的参数将成为虚拟表的 HIDDEN 列的约束。例如，“generate_series”扩展（位于源代码树的 ext/misc/series.c 文件中）使用以下架构实现同名虚拟表：</font> <pre class="code">CREATE TABLE generate_series(
  value,
  start HIDDEN,
  stop HIDDEN,
  step HIDDEN
);
</pre> <font _mstmutation="1" _msttexthash="2227642326" _msthash="27">此表的实现中的 sqlite3_module.xBestIndex 方法检查针对 HIDDEN 列的相等约束，并将这些约束用作输入参数来确定要生成的整数 “值” 输出的范围。合理的默认值用于任何不受约束的列。例如，要列出 5 到 50 之间的所有整数：</font> <pre class="code">SELECT value FROM generate_series(5,50);
</pre> <font _mstmutation="1" _msttexthash="65372515" _msthash="26">前面的查询等效于以下内容：</font> <pre class="code">SELECT value FROM generate_series WHERE start=5 AND stop=50;
</pre> <font _mstmutation="1" _msttexthash="31676958053" _msthash="25">虚拟表名称上的参数将按顺序与隐藏列匹配。参数的数量可以小于隐藏列的数量，在这种情况下，后面的隐藏列不受约束。但是，如果参数数多于虚拟表中的隐藏列数，则会导致错误。从 SQLite 版本 3.14.0 （2016-08-08） 开始，传递到 sqlite3_declare_vtab（） 的 CREATE TABLE 语句可能包含 WITHOUT ROWID 子句。这对于虚拟表行无法轻松映射为唯一整数的情况非常有用。包含 WITHOUT ROWID 的 CREATE TABLE 语句必须将一个或多个列定义为 PRIMARY KEY。PRIMARY KEY 的每一列都必须单独为 NOT NULL，并且每行的所有列都必须是唯一的。请注意，SQLite 不会对 WITHOUT ROWID 虚拟表强制执行 PRIMARY KEY。执行是底层虚拟表实现的责任。但是SQLite确实假设PRIMARY KEY约束是有效的 - 标识的列确实是UNIQUE而不是NULL - 并且它使用该假设来优化针对虚拟表的查询。rowid 列在 WITHOUT ROWID 虚拟表上无法访问（当然）。xUpdate 方法最初是围绕将 ROWID 作为单个值而设计的。xUpdate 方法已扩展为容纳任意 PRIMARY KEY 代替 ROWID，但 PRIMARY KEY 仍必须只有一列。因此，SQLite 将拒绝任何具有多个 PRIMARY KEY 列和非 NULL xUpdate 方法的 WITHOUT ROWID 虚拟表。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xDestroy.html">xDestroy</a></td><td width="50%"><pre class="code">int (*xDestroy)(sqlite3_vtab *pVTab);
</pre> <font _mstmutation="1" _msttexthash="4268546724" _msthash="24">此方法释放与虚拟表的连接，就像 xDisconnect 方法一样，它还会销毁底层表实现。此方法撤消 xCreate 的工作。每当使用虚拟表的数据库连接关闭时，都会调用 xDisconnect 方法。仅当对虚拟表执行 DROP TABLE 语句时，才会调用 xDestroy 方法。每个虚拟表实现都需要 xDestroy 方法，但如果对特定虚拟表有意义，则 xDisconnect 和 xDestroy 方法是可以接受的。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xDisconnect.html">xDisconnect</a></td><td width="50%"><pre class="code">int (*xDisconnect)(sqlite3_vtab *pVTab);
</pre> <font _mstmutation="1" _msttexthash="4505877727" _msthash="23">该方法释放与虚拟表的连接。仅销毁 sqlite3_vtab 对象。虚拟表不会被销毁，并且与虚拟表关联的任何后备存储将保留。此方法撤消 xConnect 的工作。此方法是连接到虚拟表的析构函数。将此方法与 xDestroy 进行对比。xDestroy 是整个虚拟表的析构函数。每个虚拟表实现都需要 xDisconnect 方法，但如果对特定虚拟表有意义，则 xDisconnect 和 xDestroy 方法是可以接受的。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xEof.html">xEof</a></td><td width="50%"><pre class="code">int (*xEof)(sqlite3_vtab_cursor*);
</pre> <font _mstmutation="1" _msttexthash="1476586267" _msthash="22">如果指定的游标当前指向有效的数据行，则 xEof 方法必须返回 false（零），否则返回 true（非零）。此方法由SQL引擎在每次xFilter和xNext调用后立即调用。每个虚拟表实现都需要 xEof 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xFilter.html">xFilter</a></td><td width="50%"><pre class="code">int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
              int argc, sqlite3_value **argv);
</pre> <font _mstmutation="1" _msttexthash="21424256555" _msthash="21">此方法开始搜索虚拟表。第一个参数是由 xOpen 打开的游标。接下来的两个参数定义 xBestIndex 之前选择的特定搜索索引。idxNum 和 idxStr 的特定含义并不重要，只要 xFilter 和 xBestIndex 的含义一致即可。xBestIndex 函数可能已使用 sqlite3_index_info 结构的 aConstraintUsage[].argvIndex 值请求某些表达式的值。这些值使用 argc 和 argv 参数传递给 xFilter。如果虚拟表包含与搜索条件匹配的一行或多行，则光标必须左指向第一行。对 xEof 的后续调用必须返回 false（零）。如果没有匹配的行，则游标必须处于将导致 xEof 返回 true（非零）的状态。SQLite 引擎将使用 xColumn 和 xRowid 方法来访问该行内容。xNext 方法将用于前进到下一行。如果成功，此方法必须返回 SQLITE_OK，如果发生错误，则必须返回 sqlite 错误代码。每个虚拟表实现都需要 xFilter 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xFindFunction.html">xFindFunction</a></td><td width="50%"><pre class="code">int (*xFindFunction)(
  sqlite3_vtab *pVtab,
  int nArg,
  const char *zName,
  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
  void **ppArg
);
</pre> <font _mstmutation="1" _msttexthash="64429401634" _msthash="20">在 sqlite3_prepare（） 期间调用此方法，以便为虚拟表实现提供重载函数的机会。此方法可以设置为 NULL ，在这种情况下，不会发生重载。当函数使用虚拟表中的列作为其第一个参数时，将调用此方法以查看虚拟表是否要重载该函数。前三个参数是输入：虚拟表、函数的参数数和函数的名称。如果不需要重载，此方法返回 0。为了重载函数，此方法将新的函数实现写入 *pxFunc，并将用户数据写入 *ppArg 并返回 1 或 SQLITE_INDEX_CONSTRAINT_FUNCTION 到 255 之间的数字。从历史上看，xFindFunction（） 的返回值要么是 0，要么是 1。0 表示函数未重载，1 表示函数重载。版本 3.25.0 （2018-09-15） 中添加了返回 SQLITE_INDEX_CONSTRAINT_FUNCTION 或更大值的功能。如果 xFindFunction 返回 SQLITE_INDEX_CONSTRAINT_FUNCTION 或更大，则表示该函数采用两个参数，并且该函数可以用作查询的 WHERE 子句中的布尔值，并且虚拟表能够利用该函数来加速查询结果。当 xFindFunction 返回 SQLITE_INDEX_CONSTRAINT_FUNCTION 或更大时，返回的值将成为传递到 xBestIndex（） 的约束之一的 sqlite3_index_info.aConstraint.op 值。该函数的第一个参数是由约束的 aConstraint[].iColumn 字段标识的列，该函数的第二个参数是将传递到 xFilter（） 的值（如果设置了 aConstraintUsage[].argvIndex 值）或从 sqlite3_vtab_rhs_value（） 返回的值。Geopoly 模块是利用 SQLITE_INDEX_CONSTRAINT_FUNCTION 提高性能的虚拟表的一个示例。Geopoly 的 xFindFunction（） 方法返回 geopoly_overlap（） SQL 函数的 SQLITE_INDEX_CONSTRAINT_FUNCTION，geopoly_within（） SQL 函数返回 SQLITE_INDEX_CONSTRAINT_FUNCTION+1。这允许对查询进行搜索优化，例如：</font> <pre class="code">SELECT * FROM geopolytab WHERE geopoly_overlap(_shape, $query_polygon);
SELECT * FROM geopolytab WHERE geopoly_within(_shape, $query_polygon);
</pre> <font _mstmutation="1" _msttexthash="12953661409" _msthash="19">请注意，中缀函数（LIKE、GLOB、REGEXP 和 MATCH）会反转其参数的顺序。所以 “like（A，B）” 通常与 “B like A” 的工作方式相同。但是，xFindFunction（） 始终看起来是最左边的参数，而不是第一个逻辑参数。因此，对于形式“B like A”，SQLite 会查看左作数“B”，如果该作数是虚拟表列，则它会在该虚拟表上调用 xFindFunction（） 方法。但是，如果使用形式“ like（A，B）”，则SQLite会检查A项以查看它是否是虚拟表的列，如果是，则为列A的虚拟表调用xFindFunction（）方法。此例程返回的函数指针必须在第一个参数中给定的 sqlite3_vtab 对象的生存期内有效。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xNext.html">xNext</a></td><td width="50%"><pre class="code">int (*xNext)(sqlite3_vtab_cursor*);
</pre> <font _mstmutation="1" _msttexthash="5812537484" _msthash="18">xNext 方法将虚拟表游标前进到 xFilter 启动的结果集的下一行。如果在调用此例程时光标已指向最后一行，则光标不再指向有效数据，并且对 xEof 方法的后续调用必须返回 true（非零）。如果游标成功前进到另一行内容，则对 xEof 的后续调用必须返回 false（零）。如果成功，此方法必须返回 SQLITE_OK，如果发生错误，则必须返回 sqlite 错误代码。每个虚拟表实现都需要 xNext 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xOpen.html">xOpen</a></td><td width="50%"><pre class="code">int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
</pre> <font _mstmutation="1" _msttexthash="12238221996" _msthash="17">xOpen 方法创建一个用于访问（读取和/或写入）虚拟表的新游标。成功调用此方法将为 sqlite3_vtab_cursor（或子类）分配内存，初始化新对象，并使 *ppCursor 指向新对象。然后，成功的调用将返回 SQLITE_OK。对于每次成功调用此方法，SQLite 核心稍后将调用 xClose 方法来销毁分配的游标。xOpen 方法不需要初始化 sqlite3_vtab_cursor 结构的 pVtab 字段。SQLite 核心将自动处理该琐事。虚拟表实现必须能够支持任意数量的同时打开的游标。最初打开时，游标处于 undefined 状态。SQLite 核心将在尝试定位游标或从游标读取之前调用游标上的 xFilter 方法。每个虚拟表实现都需要 xOpen 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xRelease.html">xRelease</a></td><td width="50%"><pre class="code">int (*xSavepoint)(sqlite3_vtab *pVtab, int);
int (*xRelease)(sqlite3_vtab *pVtab, int);
int (*xRollbackTo)(sqlite3_vtab *pVtab, int);
</pre> <font _mstmutation="1" _msttexthash="18098071459" _msthash="16">这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且仅在 SQLite 版本 3.7.7 （2011-06-23） 及更高版本中调用。当 xSavepoint（X，N） 被调用时，这是向虚拟表 X 发出的信号，表明它应该将其当前状态保存为 savepoint N。对 xRollbackTo（X，R） 的后续调用意味着虚拟表的状态应返回到上次调用 xSavepoint（X，R） 时的状态。对 xRollbackTo（X，R） 的调用将使所有具有 N&gt;R 的保存点失效;任何无效的 Savepoint 都不会回滚或释放，除非首先通过调用 xSavepoint（） 重新初始化。调用 xRelease（X，M） 会使 N&gt;=M 的所有保存点失效。除非在调用 xBegin（） 和 xCommit（） 或 xRollback（） 之间，否则不会调用任何 xSavepoint（）、xRelease（） 或 xRollbackTo（） 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xRename.html">xRename</a></td><td width="50%"><pre class="code">int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);
</pre> <font _mstmutation="1" _msttexthash="10476957231" _msthash="15">此方法通知虚拟表实现，虚拟表将被赋予新名称。如果此方法返回 SQLITE_OK则 SQLite 会重命名表。如果此方法返回错误代码，则会阻止重命名。xRename 方法是可选的。如果省略，则不能使用 ALTER TABLE RENAME 命令重命名虚拟表。在调用此方法之前启用 PRAGMA legacy_alter_table 设置，并在此方法完成后恢复 legacy_alter_table 的值。这对于使用影子表的虚拟表的正确作是必需的，其中必须重命名影子表以匹配新的虚拟表名称。如果 legacy_alter_format 处于关闭状态，则每次 xRename 方法尝试更改影子表的名称时，都会为虚拟表调用 xConnect 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xRollback.html">xRollback</a></td><td width="50%"><pre class="code">int (*xRollback)(sqlite3_vtab *pVTab);
</pre> <font _mstmutation="1" _msttexthash="729166867" _msthash="14">此方法会导致虚拟表事务回滚。此方法是可选的。sqlite3_module 的 xRollback 指针可能为 NULL。对此方法的调用始终在对 xBegin 的先前调用之后。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xRollbackTo.html">xRollbackTo</a></td><td width="50%"><pre class="code">int (*xSavepoint)(sqlite3_vtab *pVtab, int);
int (*xRelease)(sqlite3_vtab *pVtab, int);
int (*xRollbackTo)(sqlite3_vtab *pVtab, int);
</pre> <font _mstmutation="1" _msttexthash="18098071459" _msthash="13">这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且仅在 SQLite 版本 3.7.7 （2011-06-23） 及更高版本中调用。当 xSavepoint（X，N） 被调用时，这是向虚拟表 X 发出的信号，表明它应该将其当前状态保存为 savepoint N。对 xRollbackTo（X，R） 的后续调用意味着虚拟表的状态应返回到上次调用 xSavepoint（X，R） 时的状态。对 xRollbackTo（X，R） 的调用将使所有具有 N&gt;R 的保存点失效;任何无效的 Savepoint 都不会回滚或释放，除非首先通过调用 xSavepoint（） 重新初始化。调用 xRelease（X，M） 会使 N&gt;=M 的所有保存点失效。除非在调用 xBegin（） 和 xCommit（） 或 xRollback（） 之间，否则不会调用任何 xSavepoint（）、xRelease（） 或 xRollbackTo（） 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xRowId.html">xRowId</a></td><td width="50%"><pre class="code">int (*xRowid)(sqlite3_vtab_cursor *pCur, sqlite_int64 *pRowid);
</pre> <font _mstmutation="1" _msttexthash="1274892749" _msthash="12">成功调用此方法将导致 *pRowid 填充虚拟表游标 pCur 当前指向的行的 rowid。此方法在成功时返回 SQLITE_OK。失败时，它会返回相应的错误代码。每个虚拟表实现都需要 xRowid 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xSavepoint.html">xSavepoint</a></td><td width="50%"><pre class="code">int (*xSavepoint)(sqlite3_vtab *pVtab, int);
int (*xRelease)(sqlite3_vtab *pVtab, int);
int (*xRollbackTo)(sqlite3_vtab *pVtab, int);
</pre> <font _mstmutation="1" _msttexthash="18098071459" _msthash="11">这些方法为虚拟表实现提供了实现嵌套事务的机会。它们始终是可选的，并且仅在 SQLite 版本 3.7.7 （2011-06-23） 及更高版本中调用。当 xSavepoint（X，N） 被调用时，这是向虚拟表 X 发出的信号，表明它应该将其当前状态保存为 savepoint N。对 xRollbackTo（X，R） 的后续调用意味着虚拟表的状态应返回到上次调用 xSavepoint（X，R） 时的状态。对 xRollbackTo（X，R） 的调用将使所有具有 N&gt;R 的保存点失效;任何无效的 Savepoint 都不会回滚或释放，除非首先通过调用 xSavepoint（） 重新初始化。调用 xRelease（X，M） 会使 N&gt;=M 的所有保存点失效。除非在调用 xBegin（） 和 xCommit（） 或 xRollback（） 之间，否则不会调用任何 xSavepoint（）、xRelease（） 或 xRollbackTo（） 方法。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xSync.html">xSync</a></td><td width="50%"><pre class="code">int (*xSync)(sqlite3_vtab *pVTab);
</pre> <font _mstmutation="1" _msttexthash="3489369949" _msthash="10">此方法表示虚拟表上的两阶段提交的开始。此方法是可选的。sqlite3_module 的 xSync 指针可能为 NULL。此方法仅在调用 xBegin 方法之后以及 xCommit 或 xRollback 之前调用。为了实现两阶段提交，在对任何虚拟表调用 xCommit 方法之前，将调用所有虚拟表上的 xSync 方法。如果任何 xSync 方法失败，则回滚整个事务。</font> </td></tr>
<tr valign="top"><td width="50%"><img src="./System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule~Members_files/pubmethod.gif"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.xUpdate.html">xUpdate</a></td><td width="50%"><pre class="code">int (*xUpdate)(
  sqlite3_vtab *pVTab,
  int argc,
  sqlite3_value **argv,
  sqlite_int64 *pRowid
);
</pre> <font _mstmutation="1" _msttexthash="53719714594" _msthash="9">对虚拟表的所有更改都是使用 xUpdate 方法进行的。此方法可用于插入、删除或更新。argc 参数指定 argv 数组中的条目数。argc 的值将为 1 （对于纯删除作）或 N+2 （插入、替换或更新），其中 N 是表中的列数。在上一句中， N 包括任何隐藏的列。每个 argv 条目在 C 中都有一个非 NULL 值，但可能包含 SQL 值 NULL。换句话说，<tt _mstmutation="1" _istranslated="1">argv[i]！=0</tt> 对于 <b _mstmutation="1" _istranslated="1">i</b> 介于 0 和 <tt _mstmutation="1" _istranslated="1">argc-1</tt> 之间，这始终是正确的。但是，可能会出现 <tt _mstmutation="1" _istranslated="1">sqlite3_value_type（argv[i]）==SQLITE_NULL</tt> 的情况。argv[0] 参数是虚拟表中需要删除的一行的 rowid。如果 argv[0] 是 SQL NULL，则不会发生删除。argv[1] 参数是要插入到虚拟表中的新行的 rowid。如果 argv[1] 是 SQL NULL，则实现必须为新插入的行选择 rowid。后续的 argv[] 条目包含虚拟表的列的值，按列的声明顺序排列。列数将与 xConnect 或 xCreate 方法使用 sqlite3_declare_vtab（） 调用进行的表声明匹配。包括所有隐藏的列。当在没有rowid（argc&gt;1，argv[1]是SQL NULL）的情况下进行插入时，在使用ROWID的虚拟表上（但不在WITHOUT ROWID虚拟表上），实现必须将*pRowid设置为新插入行的rowid;这将成为 sqlite3_last_insert_rowid（） 函数返回的值。在所有其他情况下设置此值是无害的 no-op;如果argc==1或argv[1]不是SQL NULL，则SQLite引擎将忽略*pRowid返回值。每次调用 xUpdate 都属于如下所示的情况之一。并不是说对 <b _mstmutation="1" _istranslated="1">argv[i]</b> 的引用是指 argv[i] 对象中保存的 SQL 值，而不是 argv[i] 对象本身。</font> <pre class="code"><dl><dt><b>argc = 1 <br> argv[0] ≠ NULL</b></dt><dd>
            DELETE: The single row with rowid or PRIMARY KEY equal to argv[0] is deleted. 
            No insert occurs.
            </dd><dt><b>argc &gt; 1 <br> argv[0] = NULL</b></dt><dd>
            INSERT: A new row is inserted with column values taken from
            argv[2] and following.  In a rowid virtual table, if argv[1] is an SQL NULL,
            then a new unique rowid is generated automatically.  The argv[1] will be NULL
            for a WITHOUT ROWID virtual table, in which case the implementation should
            take the PRIMARY KEY value from the appropriate column in argv[2] and following.
            </dd><dt><b>argc &gt; 1 <br> argv[0] ≠ NULL <br> argv[0] = argv[1]</b></dt><dd>
            UPDATE:
            The row with rowid or PRIMARY KEY argv[0] is updated with new values 
            in argv[2] and following parameters.
            </dd><dt><b>argc &gt; 1 <br> argv[0] ≠ NULL <br> argv[0] ≠ argv[1]</b></dt><dd>
            UPDATE with rowid or PRIMARY KEY change:
            The row with rowid or PRIMARY KEY argv[0] is updated with 
            the rowid or PRIMARY KEY in argv[1] 
            and new values in argv[2] and following parameters. This will occur 
            when an SQL statement updates a rowid, as in the statement:
            <p></p><pre class="code">               UPDATE table SET rowid=rowid+1 WHERE ...; 
            </pre><p></p></dd></dl></pre> <font _mstmutation="1" _msttexthash="76975563639" _msthash="8">当且仅当 xUpdate 方法成功时，xUpdate 方法必须返回 SQLITE_OK。如果发生故障，xUpdate 必须返回相应的错误代码。失败时，可以选择使用 sqlite3_mprintf（） 或 sqlite3_malloc（） 等函数将 pVTab-&gt;zErrMsg 元素替换为存储在从 SQLite 分配的内存中的错误消息文本。如果 xUpdate 方法违反了虚拟表的某些约束（包括但不限于尝试存储错误数据类型的值、尝试存储太大或太小的值，或者尝试更改只读值），则 xUpdate 必须失败并显示相应的错误代码。如果 xUpdate 方法正在执行 UPDATE，则可以使用 sqlite3_value_nochange（X） 来发现 UPDATE 语句实际修改了虚拟表的哪些列。sqlite3_value_nochange（X） 接口为不更改的列返回 true。在每次 UPDATE 时，SQLite 将首先为表中的每个不变列分别调用 xColumn 以获取该列的值。xColumn 方法可以通过调用 sqlite3_vtab_nochange（） 来检查列在 SQL 级别是否保持不变。如果 xColumn 看到该列没有被修改，它应该返回而不使用 sqlite3_result_xxxxx（） 接口之一设置结果。只有在这种情况下，sqlite3_value_nochange（） 才会在 xUpdate 方法中为 true。如果 xColumn 确实调用了一个或多个 sqlite3_result_xxxxx（） 接口，则 SQLite 理解为列值的更改以及 xUpdate 中对该列的 sqlite3_value_nochange（） 调用将返回 false。调用 xUpdate 方法时，虚拟表实例上甚至虚拟表的行上可能打开并正在使用一个或多个 sqlite3_vtab_cursor 对象。xUpdate 的实现必须准备好尝试从其他现有游标中删除或修改表的行。如果虚拟表无法容纳此类更改，则 xUpdate 方法必须返回错误代码。xUpdate 方法是可选的。如果虚拟表的sqlite3_module中的 xUpdate 指针是 NULL 指针，则虚拟表是只读的。</font> </td></tr></tbody></table>
      </div>
      <h4 class="dtH4" _msttexthash="13182286" _msthash="4">另请参阅</h4>
      <p>
        <font _mstmutation="1" _msttexthash="88983440" _msthash="5"><a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/System.Data.SQLite~System.Data.SQLite.ISQLiteNativeModule.html" _mstmutation="1" _istranslated="1">ISQLiteNativeModule 接口</a> |<a href="file:///D:/LiuChen_Person/Code/Git_Resop/Jingan567/LcDataBaseCoverAll/SqliteTemplate/FileDocument/SQLite.NET/~System.Data.SQLite.html" _mstmutation="1" _istranslated="1">System.Data.SQLite 命名空间</a></font></p>
      
      <hr>
      <div id="footer">
        <p>
          <a href="mailto:sqlite-users@mailinglists.sqlite.org?subject=SQLite%20ADO.NET%20Provider%20Documentation%20Feedback:%20ISQLiteNativeModule%20Members" _msttexthash="36201139" _msthash="6">就此主题发送评论。</a>
        </p>
        <p>
        </p>
        <p _msttexthash="58771310" _msthash="7">由 <a href="http://ndoc3.sourceforget.net/" _istranslated="1">NDoc3</a> 从程序集 System.Data.SQLite [1.0.119.0] 生成</p>
      </div>
    </div>
  
</body></html>